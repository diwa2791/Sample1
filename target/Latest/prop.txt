package com.example.compare;

import org.springframework.jdbc.core.JdbcTemplate;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

public class TableCompareEngine {

    private final JdbcTemplate testJdbc;
    private final JdbcTemplate prodJdbc;

    public TableCompareEngine(JdbcTemplate testJdbc,
                              JdbcTemplate prodJdbc) {
        this.testJdbc = testJdbc;
        this.prodJdbc = prodJdbc;
    }

    /* ============================================================
       MAIN ENTRY METHOD
       ============================================================ */

    public List<Map<String, Object>> executeDiffQuery(
            String testQuery,
            String prodQuery,
            List<String> pkColumns) {

        if (pkColumns == null || pkColumns.isEmpty()) {
            throw new IllegalArgumentException("PK columns required");
        }

        // 1️⃣ Fetch data
        List<Map<String, Object>> testRows =
                testJdbc.queryForList(testQuery);

        List<Map<String, Object>> prodRows =
                prodJdbc.queryForList(prodQuery);

        // 2️⃣ Build lookup maps
        Map<String, Map<String, Object>> testMap =
                buildMap(testRows, pkColumns);

        Map<String, Map<String, Object>> prodMap =
                buildMap(prodRows, pkColumns);

        // 3️⃣ Compare
        Set<String> allKeys = new HashSet<>();
        allKeys.addAll(testMap.keySet());
        allKeys.addAll(prodMap.keySet());

        List<Map<String, Object>> result = new ArrayList<>();

        for (String key : allKeys) {

            Map<String, Object> testRow = testMap.get(key);
            Map<String, Object> prodRow = prodMap.get(key);

            if (testRow == null) {
                result.add(buildUiRow(
                        null, prodRow, pkColumns, "ONLY_IN_PROD"));
            }
            else if (prodRow == null) {
                result.add(buildUiRow(
                        testRow, null, pkColumns, "ONLY_IN_TEST"));
            }
            else if (!rowsEqual(testRow, prodRow)) {
                result.add(buildUiRow(
                        testRow, prodRow, pkColumns, "DIFFERENT"));
            }
        }

        return result;
    }

    /* ============================================================
       BUILD MAP USING PK
       ============================================================ */

    private Map<String, Map<String, Object>> buildMap(
            List<Map<String, Object>> rows,
            List<String> pkColumns) {

        Map<String, Map<String, Object>> map = new HashMap<>();

        for (Map<String, Object> row : rows) {

            validatePkPresence(row, pkColumns);

            String key = buildKey(row, pkColumns);
            map.put(key, row);
        }

        return map;
    }

    /* ============================================================
       BUILD UNIQUE KEY FROM PK
       ============================================================ */

    private String buildKey(
            Map<String, Object> row,
            List<String> pkColumns) {

        return pkColumns.stream()
                .map(pk -> Objects.toString(row.get(pk), "NULL"))
                .collect(Collectors.joining("|"));
    }

    /* ============================================================
       VALIDATE PK EXISTS IN QUERY
       ============================================================ */

    private void validatePkPresence(
            Map<String, Object> row,
            List<String> pkColumns) {

        for (String pk : pkColumns) {
            if (!row.containsKey(pk)) {
                throw new IllegalArgumentException(
                        "PK column missing in select query: " + pk);
            }
        }
    }

    /* ============================================================
       ROW COMPARISON
       ============================================================ */

    private boolean rowsEqual(
            Map<String, Object> r1,
            Map<String, Object> r2) {

        Set<String> allCols = new HashSet<>();
        allCols.addAll(r1.keySet());
        allCols.addAll(r2.keySet());

        for (String col : allCols) {

            Object v1 = normalize(r1.get(col));
            Object v2 = normalize(r2.get(col));

            if (!Objects.equals(v1, v2)) {
                return false;
            }
        }

        return true;
    }

    /* ============================================================
       NORMALIZER (Oracle/Postgres Safe)
       ============================================================ */

    private Object normalize(Object value) {

        if (value == null)
            return null;

        if (value instanceof Number)
            return new BigDecimal(value.toString());

        if (value instanceof java.sql.Timestamp)
            return ((java.sql.Timestamp) value).toInstant();

        return value.toString().trim();
    }

    /* ============================================================
       BUILD UI-COMPATIBLE RESULT ROW
       ============================================================ */

    private Map<String, Object> buildUiRow(
            Map<String, Object> testRow,
            Map<String, Object> prodRow,
            List<String> pkColumns,
            String status) {

        Map<String, Object> result =
                new LinkedHashMap<>();

        Map<String, Object> source =
                testRow != null ? testRow : prodRow;

        // 1️⃣ PK columns
        for (String pk : pkColumns) {
            result.put("pk_" + pk,
                    source != null ? source.get(pk) : null);
        }

        // 2️⃣ All other columns
        Set<String> allColumns = new HashSet<>();

        if (testRow != null)
            allColumns.addAll(testRow.keySet());

        if (prodRow != null)
            allColumns.addAll(prodRow.keySet());

        for (String col : allColumns) {

            if (pkColumns.contains(col))
                continue;

            result.put("t_" + col,
                    testRow != null ? testRow.get(col) : null);

            result.put("p_" + col,
                    prodRow != null ? prodRow.get(col) : null);
        }

        // 3️⃣ Status
        result.put("status", status);

        return result;
    }
}


----------------------
TableCompareEngine engine =
        new TableCompareEngine(testJdbc, prodJdbc);

List<Map<String,Object>> result =
        engine.executeDiffQuery(
                "select * from acct_status_config where version=0.1",
                "select * from acct_status_config where version=0.1",
                List.of("ctrycd", "pmttp", "subpmttp"));



------------------
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

public static void printAsJson(List<Map<String, Object>> data) {

    try {
        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        String json = mapper.writeValueAsString(data);

        System.out.println("========= JSON OUTPUT =========");
        System.out.println(json);
        System.out.println("================================");

    } catch (Exception e) {
        e.printStackTrace();
    }
}

