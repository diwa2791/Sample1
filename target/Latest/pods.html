<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <base href="/" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pods - K8s Dashboard</title>

  <link rel="stylesheet" href="/css/styles.css" />
  <script src="/js/sidebar.js" defer></script>
</head>

<body data-page="pods">
  <!-- Sidebar placeholder: we will load /fragments/sidebar.html into this -->
  <div id="sidebar-placeholder"></div>

  <!-- Topbar (static, no Thymeleaf) -->
  <header class="topbar">
    <div class="brand">K8s Dashboard</div>
    <div class="controls">
		<button id="switchEnvBtn" type="button" class="btn btn-primary">Switch Env/NS</button>
		<span id="currentEnvNs" style="margin-left:8px; font-size:12px; color:#6b7280;"></span>

      <input id="search" type="text" placeholder="Search..." />
      <button id="refreshBtn">Refresh</button>
    </div>
  </header>

  <!-- Env/NS Modal (uses shared modal styles) -->
  <div id="envModal" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal">
      <div class="modal-header">
        <h3>Select Environment & Namespace</h3>
        <button class="modal-close" id="envCloseBtn">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="form-row">
          <label for="envSelect">Environment</label>
          <select id="envSelect" class="inp" style="min-width:220px;"></select>
        </div>
        <div class="form-row" style="margin-top:10px;">
          <label for="nsSelect">Namespace</label>
          <select id="nsSelect" class="inp" style="min-width:220px;" disabled></select>
        </div>
      </div>
      <div class="modal-footer">
        <button id="envCancelBtn" class="btn outline">Cancel</button>
        <button id="envApplyBtn" class="btn" disabled>Apply</button>
      </div>
    </div>
  </div>

  <main class="container" id="mainContent" style="display:none; visibility:hidden;" style="visibility:hidden;">
    <!-- Summary -->
    <section class="summary">
      <div class="card card-filter" id="card-running" data-filter="Running">
        <div class="card-title">Running (1/1)</div>
        <div id="count-running" class="card-value">0</div>
      </div>
      <div class="card card-filter" id="card-pending" data-filter="Pending">
        <div class="card-title">Pending (Creating)</div>
        <div id="count-pending" class="card-value">0</div>
      </div>
      <div class="card card-filter" id="card-abnormal" data-filter="Abnormal">
        <div class="card-title">Abnormal</div>
        <div id="count-abnormal" class="card-value">0</div>
      </div>
      <div class="card card-filter" id="card-services-zero" data-filter="ServicesZero">
        <div class="card-title">Services (0 pods)</div>
        <div id="count-services-zero" class="card-value">0</div>
      </div>
    </section>

    <!-- Pods Table -->
    <section class="table-wrap">
      <table id="podsTable">
        <thead>
          <tr>
            <th style="width:52%;">Name</th>
            <th>Status</th>
            <th>Age</th>
            <th style="width:240px;">Actions</th>
          </tr>
        </thead>
        <tbody id="podsBody"></tbody>
      </table>
    </section>
  </main>

  <!-- Shared modal overlay (as in your previous file) -->
  <div id="modalOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modalTitle">Edit</h3>
        <button class="modal-close" onclick="closeModal()">Ã—</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer">
        <button class="btn outline" onclick="closeModal()">Cancel</button>
        <button class="btn" id="modalSaveBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- Full ConfigMap Editor Modal -->
  <div id="fullCmOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal large">
      <div class="modal-header">
        <h3 id="fullCmTitle">Edit ConfigMap</h3>
        <button class="modal-close" onclick="closeFullCm()">Ã—</button>
      </div>

      <div class="modal-meta" style="display:flex;gap:12px;align-items:center;margin-bottom:8px;">
        <div id="fullCmInfo" style="color:var(--muted);font-size:13px"></div>
        <div style="margin-left:auto;">
          <button class="btn outline" id="downloadCmBtn">Download</button>
        </div>
      </div>

      <div class="modal-body" style="padding:0;">
        <textarea id="fullCmTextarea" spellcheck="false"
          style="width:100%;height:420px;padding:12px;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Courier New', monospace; font-size:13px; background:var(--panel); color:#e6eef6; border:none; resize:vertical;"></textarea>
      </div>

      <div class="modal-footer">
        <button class="btn outline" onclick="closeFullCm()">Cancel</button>
        <button class="btn" id="saveFullCmBtn">Save</button>
      </div>
    </div>
  </div>
  
  <script id="env-data"
          type="application/json"
          th:utext="${envConfigJson}">
  </script>
  <script>
    window.KDASH_ENV_MAP = {
      dev: ["default","web","db"],
      staging: ["default","payments","search"],
      prod: ["core","billing","realtime"]
    };
	window.__detailLock = false;  
  </script>

  <!-- ========== Script: load sidebar fragment, then run your existing page logic ========== -->
  <script>
    // Load /fragments/sidebar.html into #sidebar-placeholder
    (async function loadSidebar() {
      try {
        const res = await fetch('/fragments/sidebar.html', { cache: 'no-store' });
        if (res.ok) {
          const html = await res.text();
          document.getElementById('sidebar-placeholder').innerHTML = html;
          // sidebar.js will run (it is loaded with defer), but if your fragment had scripts we would re-attach them here.
        } else {
          // Minimal fallback
          document.getElementById('sidebar-placeholder').innerHTML = `
            <nav class="sidebar"><div class="sidebar-inner">
              <ul class="nav">
                <li><a href="/pods.html" class="nav-link">Pods</a></li>
                <li><a href="/services.html" class="nav-link">Services</a></li>
                <li><a href="/deployments.html" class="nav-link">Deployments</a></li>
              </ul>
            </div></nav>`;
        }
      } catch {
        /* ignore */
      }
    })();
	
	
	/* ---------- Card filter state ---------- */
	let statusFilter = null; // one of: null | "Running" | "Pending" | "Abnormal" | "ServicesZero"

	/* Map cards by id (adjust ids if your markup differs) */
	const cardEls = {
	  Running:      document.getElementById('card-running'),
	  Pending:      document.getElementById('card-pending'),
	  Abnormal:     document.getElementById('card-abnormal'),
	  ServicesZero: document.getElementById('card-services-zero')
	};

	/* Highlight the active card (and set ARIA for accessibility) */
	function updateCardActiveState() {
	  Object.entries(cardEls).forEach(([key, el]) => {
	    if (!el) return;
	    const active = (statusFilter === key);
	    el.classList.toggle('active', active);
	    el.setAttribute('aria-pressed', active ? 'true' : 'false');
	  });
	}

	/* Apply or clear a filter, then re-render from cached data */
	function applyFilter(next) {
	  // Non-toggle: always set the clicked card's filter and render
	  statusFilter = next;
	  updateCardActiveState();
	  if (Array.isArray(window.__lastPods)) {
	    renderPods(window.__lastPods, window.__lastSummary || {});
	  } else if (typeof fetchSummaryAndRender === 'function') {
	    fetchSummaryAndRender();
	  }
	}


	/* Wire single click handler per card â€” uses data-filter, not innerText */
	function wireCardClicks() {
	  document.querySelectorAll('.card.card-filter').forEach(el => {
	    const filter = el.dataset.filter; // MUST be exactly Running | Pending | Abnormal | ServicesZero
	    el.addEventListener('click', () => applyFilter(filter), { passive: true });
	  });
	}

	/* Call this once after DOMContentLoaded */
	wireCardClicks();
	updateCardActiveState();
	
	
	
	/* ---------------- Globals & DOM refs ---------------- */
	const podsBody = document.getElementById('podsBody');
	const searchInput = document.getElementById('search');
	const refreshBtn = document.getElementById('refreshBtn');
	const namespaceSelect = document.getElementById('namespaceSelect');

	let currentNamespace = 'all';
	 // Running | Pending | Abnormal | ServicesZero

	
	// Modal shared elements (already exist in your page)
	const modalOverlay = document.getElementById('modalOverlay');
	const modalTitle = document.getElementById('modalTitle');
	const modalBody = document.getElementById('modalBody');
	const modalSaveBtn = document.getElementById('modalSaveBtn');

	/* modal mode state:
	   - null = closed
	   - 'configmap-full' = full notepad editor (modalBody will contain textarea#fullCmTextarea)
	   - 'replicas' = replicas UI (modalBody contains select/input)
	*/
	let modalMode = null;
	let modalContext = { namespace: null, targetName: null, resourceVersion: null };

	/* ---------------- Helper: derive service/configmap name from pod name ---------------- */
	// Removes the last two hyphen-separated segments (typical pod suffixes).
	function baseServiceNameFromPod(podName) {
	  if (!podName || typeof podName !== 'string') return podName;
	  const parts = podName.split('-');
	  if (parts.length > 2) return parts.slice(0, -2).join('-');
	  return podName;
	}
	
	// Return the Kubernetes phase ("Running", "Pending", "Failed", etc.)
	function podPhase(pod) {
	  const s = pod?.status;
	  if (!s) return '-';
	  // Phase comes from status.phase; fall back safely if someone put a string in status
	  return (typeof s === 'object' && s.phase) ? s.phase : String(s);
	}

	// Return {ready, total} from containerStatuses, or null if unavailable
	function podReadyCounts(pod) {
	  const statuses = pod?.status?.containerStatuses;
	  if (!Array.isArray(statuses)) return null;
	  const total = statuses.length;
	  const ready = statuses.reduce((acc, cs) => acc + (cs?.ready ? 1 : 0), 0);
	  return { ready, total };
	}

	// Build a friendly label like "Running (1/1)" or "Pending (0/1)"
	function podStatusLabel(pod) {
	  const phase = podPhase(pod) || '-';
	  const counts = podReadyCounts(pod);
	  if (counts && counts.total > 0) {
	    return `${phase} (${counts.ready}/${counts.total})`;
	  }
	  return phase;
	}

	// Lowercase phase for filtering/sorting
	
function isAbnormal(p) {
  try {
    const s = (p.status || '').toLowerCase();
    const norm = (typeof normalizePodStatus === 'function' ? (normalizePodStatus(p) || '') : '').toLowerCase();
    if (s === 'failed' || s === 'unknown') return true;
    if (norm.includes('crash')) return true;      // CrashLoopBackOff
    if (norm.includes('backoff')) return true;    // ImagePullBackOff, BackOff
    if (norm.includes('error')) return true;      // ErrImagePull
    if (norm.includes('oom')) return true;        // OOMKilled
    if (p.restartCount && p.restartCount > 0) return true;
    return false;
  } catch(e) { return false; }
}
function normalizePodStatus(pod) {
	  return podPhase(pod).toLowerCase();
	}

	// Optional: badge class by phase
	function badgeClassFor(pod) {
	  const phase = normalizePodStatus(pod);
	  if (phase === 'running') return 'badge ok';
	  if (phase === 'pending' || phase.includes('creating')) return 'badge warn';
	  if (phase === 'failed' || phase.includes('crash')) return 'badge danger';
	  return 'badge';
	}



	/* ---------------- Small utility: try multiple fetch endpoints ---------------- */
	/**
	 * candidates: array of URL strings
	 * returns: { res: Response, url: string } on first OK, or { res: lastNonOkResponse | null, url: attemptedUrl | null } if none OK
	 */
	 async function fetchWithFallback(candidates) {
	   let lastNonOk = null;
	   const tried = [];
	   for (const url of candidates) {
	     tried.push(url);
	     try {
	       const r = await fetch(url);
	       if (r.ok) {
	         console.info('fetchWithFallback: success', url);
	         return { res: r, url };
	       }
	       lastNonOk = { res: r, url };
	       if (r.status === 404) continue;
	       return { res: r, url };
	     } catch (err) {
	       console.warn('fetch candidate failed', url, err);
	       continue;
	     }
	   }
	   console.info('fetchWithFallback: none matched. tried:', tried);
	   return lastNonOk || { res: null, url: null };
	 }


	/* ---------------- Pod table rendering ---------------- */
	// Replace/insert this function in your script
	function createPodRow(p) {
	  // p is expected to be an object with at least: name, status, age, namespace (optional)
	  const ns = p.namespace || currentNamespace || 'default';
	  const podName = p.name || (p.metadata && p.metadata.name) || 'unknown-pod';
	  const deployName = baseServiceNameFromPod(podName);

	  const tr = document.createElement('tr');

	  // Name cell
	  const nameTd = document.createElement('td');
	  nameTd.innerHTML = `<strong>${podName}</strong><div class="text-muted small">${ns}</div>`;

	  // Status cell
	  const statusTd = document.createElement('td');
	  const badge = document.createElement('span');
	  badge.className = badgeClassFor(p);              // e.g., "badge ok" / "badge warn" / "badge danger"
	  badge.textContent = podStatusLabel(p);           // e.g., "Running (1/1)"
	  statusTd.appendChild(badge);


	  // Age cell
	  const ageTd = document.createElement('td');
	  ageTd.textContent = p.age || (p.metadata && p.metadata.creationTimestamp ? isoAge(p.metadata.creationTimestamp) : '-');

	  // Actions cell
	  const actionsTd = document.createElement('td');

	  // Helper to create buttons quickly
	  const makeBtn = (text, cls = 'btn', onClick) => {
	    const b = document.createElement('button');
	    b.className = cls;
	    b.textContent = text;
	    b.onclick = onClick;
	    return b;
	  };

	  // Logs
	  actionsTd.appendChild(makeBtn('Logs', 'btn outline small', () => openLogs(ns, podName)));


	  // Restart
	  actionsTd.appendChild(makeBtn('Restart', 'btn outline', async () => {
	    if (confirm(`Delete pod ${podName} to force restart?`)) {
	      await restartPod(ns, podName);
	      fetchSummaryAndRender();
	    }
	  }));

	  // Edit ConfigMap (derive name from deployment)
	  actionsTd.appendChild(makeBtn('Edit ConfigMap', 'btn outline small', async () => {
	    await openFullConfigMap(ns, deployName);
	  }));

	  // Edit Deployment (new)
	  actionsTd.appendChild(makeBtn('Edit Deployment', 'btn outline small', async () => {
	    await openFullDeployment(ns, deployName);
	  }));

	  // Set Replicas (open replicas modal; pass deployment name)
	  actionsTd.appendChild(makeBtn('Set Replicas', 'btn outline small', async () => {
	    openReplicasModal(ns, deployName); // or service-derived name
	  }));


	  tr.appendChild(nameTd);
	  tr.appendChild(statusTd);
	  tr.appendChild(ageTd);
	  tr.appendChild(actionsTd);
	  return tr;
	}

	
	// Convert an ISO timestamp (e.g. 2025-10-19T11:57:45Z) into a human-readable age like "3h" or "2d"
	function isoAge(isoString) {
	  if (!isoString) return '-';
	  const then = new Date(isoString);
	  const now = new Date();
	  const diff = now - then;
	  const sec = Math.floor(diff / 1000);
	  const min = Math.floor(sec / 60);
	  const hr  = Math.floor(min / 60);
	  const day = Math.floor(hr / 24);

	  if (day > 0) return day + 'd';
	  if (hr  > 0) return hr  + 'h';
	  if (min > 0) return min + 'm';
	  return sec + 's';
	}

	
	/**
	 * Poll until a given service (or derived service name) has at least one matching pod.
	 * - serviceName: the service name (or service-like name derived from pod/deployment)
	 * - namespace: namespace to check
	 * - opts: { intervalMs: 3000, timeoutMs: 60000 } optional
	 *
	 * Resolves true if pods found, false if timeout reached.
	 */
	async function pollUntilServiceHasPods(serviceName, namespace, opts = {}) {
	  const intervalMs = opts.intervalMs || 3000;
	  const timeoutMs = opts.timeoutMs || 60000;
	  const started = Date.now();

	  // Helper: checks if service selector matches any pod labels
	  const checkOnce = async () => {
	    try {
	      // try list endpoints (tolerant)
	      const svcCandidates = [
	        `/api/v1/namespaces/${encodeURIComponent(namespace)}/services/${encodeURIComponent(serviceName)}`,
	        `/api/services/${encodeURIComponent(namespace)}/${encodeURIComponent(serviceName)}`,
	        `/api/services/zero?namespace=${encodeURIComponent(namespace)}` // fallback to list if no single-get
	      ];
	      const podsCandidates = [
	        `/api/pods?namespace=${encodeURIComponent(namespace)}`,
	        `/api/v1/namespaces/${encodeURIComponent(namespace)}/pods`
	      ];

	      // Try to fetch the service object first
	      let svcRes = await fetchWithFallback([
	        `/api/v1/namespaces/${encodeURIComponent(namespace)}/services/${encodeURIComponent(serviceName)}`,
	        `/api/services/zero/${encodeURIComponent(namespace)}/${encodeURIComponent(serviceName)}`,
	        `/api/services?namespace=${encodeURIComponent(namespace)}`
	      ]);

	      let serviceObj = null;
	      if (svcRes.res && svcRes.res.ok) {
	        try {
	          const payload = await svcRes.res.json();
	          // if we got items (list), try to find by name
	          if (Array.isArray(payload)) {
	            serviceObj = payload.find(s => (s.metadata && s.metadata.name) === serviceName) || null;
	          } else if (payload && Array.isArray(payload.items)) {
	            serviceObj = payload.items.find(s => s.metadata?.name === serviceName) || null;
	          } else if (payload && payload.metadata && payload.metadata.name === serviceName) {
	            serviceObj = payload;
	          }
	        } catch (err) {
	          // ignore parse failures
	        }
	      }

	      // If we couldn't fetch service object, build a selector by convention: empty selector -> no pods; else try label derived matching
	      const selector = (serviceObj && serviceObj.spec && serviceObj.spec.selector) ? serviceObj.spec.selector : null;

	      // fetch pods
	      const podsRes = await fetchWithFallback(podsCandidates);
	      let podsList = [];
	      if (podsRes.res && podsRes.res.ok) {
	        const p = await podsRes.res.json().catch(()=>null);
	        if (Array.isArray(p)) podsList = p;
	        else if (p && Array.isArray(p.items)) podsList = p.items;
	      }

	      if (!selector || Object.keys(selector).length === 0) {
	        // If selector is absent, try to match using a best-effort heuristic:
	        // treat serviceName as deployment prefix and look for pods whose name starts with that prefix
	        return podsList.some(p => (p.metadata && p.metadata.name && p.metadata.name.startsWith(serviceName + '-')));
	      }

	      // check if any pod's labels match selector
	      return podsList.some(p => {
	        const labels = (p.metadata && p.metadata.labels) || {};
	        return Object.entries(selector).every(([k, v]) => labels[k] === v);
	      });

	    } catch (err) {
	      console.warn('pollUntilServiceHasPods: checkOnce error', err);
	      return false;
	    }
	  };

	  // fast first check
	  if (await checkOnce()) return true;

	  // poll loop
	  while (Date.now() - started < timeoutMs) {
	    await new Promise(res => setTimeout(res, intervalMs));
	    if (await checkOnce()) return true;
	  }

	  return false; // timed out
	}

	
	// Build a table row for a Service (used when ServicesZero filter selected)
	// Build a table row for a Service (accepts either a Service object or a plain string name)
	function createServiceRow(svc) {
	  let name = 'â€”', ns = currentNamespace || 'default', labels = {}, typeInfo = '';
	  if (!svc) { name = 'â€”'; }
	  else if (typeof svc === 'string') { name = svc; }
	  else if (typeof svc === 'object') {
	    name = svc.metadata?.name || svc.name || 'â€”';
	    ns = svc.metadata?.namespace || ns;
	    labels = svc.metadata?.labels || svc.spec?.selector || {};
	    typeInfo = svc.spec?.type || '';
	  } else {
	    name = String(svc);
	  }

	  const tr = document.createElement('tr');

	  const nameTd = document.createElement('td');
	  nameTd.innerHTML = `<strong>${name}</strong>
	                      <div class="text-muted small">${typeInfo} ${labels && Object.keys(labels).length ? Object.entries(labels).map(([k,v])=>k+':'+v).join(', ') : ''}</div>`;

	  const statusTd = document.createElement('td');
	  const badge = document.createElement('span');
	  badge.className = 'badge bg-warning';
	  badge.textContent = '0 pods';
	  statusTd.appendChild(badge);

	  const ageTd = document.createElement('td');
	  // If service object provided, show age; otherwise '-'
	  ageTd.textContent = svc && svc.metadata && svc.metadata.creationTimestamp ? isoAge(svc.metadata.creationTimestamp) : '-';

	  const actionsTd = document.createElement('td');

	  const makeBtn = (text, cls = 'btn', onClick) => {
	    const b = document.createElement('button');
	    b.className = cls;
	    b.textContent = text;
	    b.onclick = onClick;
	    return b;
	  };

	  // Describe (try service describe endpoint; fallback to alert)
	  actionsTd.appendChild(makeBtn('Describe', 'btn outline small', async () => {
	    try {
	      const r = await fetch(`/api/deployments/${encodeURIComponent(getNs())}/${encodeURIComponent(name)}`); // maybe service name maps to deployment
	      if (r.ok) { alert(JSON.stringify(await r.json(), null, 2)); return; }
	    } catch (e) { /* ignore */ }
	    alert('Describe: ' + name);
	  }));

	  // Edit ConfigMap (derive)
	  actionsTd.appendChild(makeBtn('Edit ConfigMap', 'btn outline small', async () => {
	    const cmName = baseServiceNameFromPod(name);
	    await openFullConfigMap(ns, cmName);
	  }));

	  // Edit Deployment (NEW)
	  actionsTd.appendChild(makeBtn('Edit Deployment', 'btn outline small', async () => {
	    const depName = baseServiceNameFromPod(name);
	    await openFullDeployment(ns, depName);
	  }));

	  // Set Replicas
	  actionsTd.appendChild(makeBtn('Set Replicas', 'btn outline small', async () => {
	    await openReplicasModal(ns, name);
	  }));

	  tr.appendChild(nameTd);
	  tr.appendChild(statusTd);
	  tr.appendChild(ageTd);
	  tr.appendChild(actionsTd);
	  return tr;
	}




	/* ---------------- Fetch pods + summary and render ---------------- */
	function getNs(){ return (window.currentNamespace || localStorage.getItem('kdash.selected.ns') || 'default'); }

	function renderPods(pods, summary) {
	  const podsBody = document.getElementById('podsBody');
	  const searchInput = document.getElementById('search');
	  if (!podsBody) return;

	  if (typeof podsBody !== 'undefined' && podsBody && !window.__detailLock) podsBody.innerHTML = '';

	  const search = (searchInput?.value || '').toLowerCase();

	  const filtered = pods.filter(p => {
	    if (statusFilter) {
	      if (statusFilter === 'Running' && p.status !== 'Running') return false;
	      if (statusFilter === 'Pending' && p.status !== 'Pending') return false;
	      if (statusFilter === 'Abnormal' && !isAbnormal(p)) return false;
	    }
	    if (search && !(p.name || '').toLowerCase().includes(search)) return false;
	    return true;
	  });

	  filtered.forEach(p => podsBody.appendChild(createPodRow(p))); // âœ… GOOD
	}


async function fetchSummaryAndRender() {
	if (window.__detailLock) return;  
	    try { if (!window.currentNamespace) return; } catch(e){}
try {
	    const ns = currentNamespace;
	    const [podsRes, summaryRes] = await Promise.all([
	      fetch('/api/pods?namespace=' + encodeURIComponent(getNs()) + '&t=' + Date.now()),
	      fetch('/api/summary?namespace=' + encodeURIComponent(getNs()) + '&t=' + Date.now())
	    ]);
	    if (!podsRes.ok || !summaryRes.ok) {
	      console.error('fetch error', podsRes.status, summaryRes.status);
	      return;
	    }
	    const pods = await podsRes.json();
        const summary = await summaryRes.json();
        window.__lastPods = pods; window.__lastSummary = summary;

        // Update counts
	    document.getElementById('count-running').textContent = summary.running ?? 0;
	    document.getElementById('count-pending').textContent = summary.pending ?? 0;
	    const abnormalCount = pods.reduce((acc, pod) => acc + (isAbnormal(pod) ? 1 : 0), 0);
    document.getElementById('count-abnormal').textContent = abnormalCount;
	    document.getElementById('count-services-zero').textContent = summary.servicesWithZeroPods ?? 0;

	    // Render filtered pods
	    const search = (searchInput?.value || '').toLowerCase();
	    if (typeof podsBody !== 'undefined' && podsBody && !window.__detailLock) podsBody.innerHTML = '';

	    window.__lastPods = pods; window.__lastSummary = summary;

    
		renderPods(pods, summary);

	    // ServicesZero card: show message
		// ServicesZero card: show message or list services with zero pods
		
if (statusFilter === 'ServicesZero') {
  podsBody.innerHTML = '<tr><td colspan="4">Scanning services with zero podsâ€¦</td></tr>';
  try {
    const ns = (namespaceSelect?.value && namespaceSelect.value !== 'all')
      ? namespaceSelect.value
      : (currentNamespace && currentNamespace !== 'all' ? currentNamespace : null);
    if (!ns) {
      podsBody.innerHTML = '<tr><td colspan="4">Select a specific namespace to see services with 0 pods.</td></tr>';
      return; // do not call backend with namespace=all
    }
const [svcRes, podsRes] = await Promise.all([
      fetch('/api/services/zero?namespace=' + encodeURIComponent(ns) + '&t=' + Date.now()),
      fetch('/api/pods?namespace=' + encodeURIComponent(ns) + '&t=' + Date.now())
    ]);
    if (!svcRes.ok || !podsRes.ok) {
      podsBody.innerHTML = '<tr><td colspan="4">Failed to load services/pods (HTTP ' + svcRes.status + '/' + podsRes.status + ')</td></tr>';
      return;
    }

    const servicesPayload = await svcRes.json().catch(()=>null);
    const podsPayload = await podsRes.json().catch(()=>null);

    const services = Array.isArray(servicesPayload) ? servicesPayload
                    : (servicesPayload && Array.isArray(servicesPayload.items) ? servicesPayload.items : []);
    const pods = Array.isArray(podsPayload) ? podsPayload
                : (podsPayload && Array.isArray(podsPayload.items) ? podsPayload.items : []);

    const podLabelsList = pods.map(p => (p?.metadata?.labels) || {});

    const selectorMatchesAnyPod = (selector) => {
      if (!selector || Object.keys(selector).length === 0) return false;
      return podLabelsList.some(lbls => {
        for (const [k,v] of Object.entries(selector)) {
          if (lbls[k] !== v) return false;
        }
        return true;
      });
    };

    const zeroServices = [];
    for (const svc of services) {
      const selector = svc?.spec?.selector || null;
      const any = selectorMatchesAnyPod(selector);
      if (!any) zeroServices.push(svc);
    }

    if (typeof podsBody !== 'undefined' && podsBody && !window.__detailLock) podsBody.innerHTML = '';
    if (zeroServices.length === 0) {
      podsBody.innerHTML = '<tr><td colspan="4">No services with zero matching pods ðŸŽ‰</td></tr>';
    } else {
      zeroServices.forEach(svc => podsBody.appendChild(createServiceRow(svc)));
    }
  } catch (e) {
    console.error('ServicesZero (Option 2) failed', e);
    podsBody.innerHTML = '<tr><td colspan="4">Error scanning services with zero pods</td></tr>';
  }
  return; // do not continue normal pod rendering
}
} catch (err) {
	    console.error('refresh error', err);
	  }
	}

	/* ---------------- Restart pod ---------------- */
	async function restartPod(namespace, podName) {
	  if (!confirm(`Delete pod ${podName} to force restart?`)) return;

	  try {
	    const url = `/api/pods/${encodeURIComponent(getNs())}/${encodeURIComponent(podName)}/restart`;
	    const res = await fetch(url, { method: 'POST' });

	    if (!res.ok) {
	      const txt = await res.text().catch(() => res.statusText);
	      alert(`Restart failed (${res.status}): ${txt}`);
	      return;
	    }

	    alert('Restart requested.');
	    // Optionally poll or just refresh summary/list:
	    if (typeof fetchSummaryAndRender === 'function') fetchSummaryAndRender();
	  } catch (e) {
	    alert('Error: ' + e.message);
	  }
	}



	/* ---------------- Namespaces loader ---------------- */
	async function loadNamespaces() {
	  const sel = namespaceSelect;
	  if (!sel) return;
	  sel.innerHTML = '';
	  const loadOpt = document.createElement('option'); loadOpt.value = 'loading'; loadOpt.textContent = 'Loading...'; loadOpt.disabled = true; sel.appendChild(loadOpt);
	  try {
	    const r = await fetch('/api/namespaces');
	    if (!r.ok) throw new Error('HTTP ' + r.status);
	    const list = await r.json();
	    sel.innerHTML = '';
	    const allOpt = document.createElement('option'); allOpt.value = 'all'; allOpt.textContent = 'All namespaces'; sel.appendChild(allOpt);
	    if (!Array.isArray(list) || list.length === 0) {
	      const none = document.createElement('option'); none.value='none'; none.textContent='-- no namespaces --'; none.disabled=true; sel.appendChild(none);
	      currentNamespace = 'all';
	      return;
	    }
	    list.forEach(ns => { const o = document.createElement('option'); o.value = ns; o.textContent = ns; sel.appendChild(o); });
	    if ([...sel.options].some(o => o.value === currentNamespace)) sel.value = currentNamespace; else { sel.value = 'all'; currentNamespace = 'all'; }
	  } catch (err) {
	    console.error('namespaces load failed', err);
	    sel.innerHTML = ''; const e = document.createElement('option'); e.value='error'; e.textContent='-- failed to load --'; e.disabled=true; sel.appendChild(e);
	  }
	}

	/* ---------------- Shared modal open/close ---------------- */
	function openModal(title, mode, namespace=null, target=null, resourceVersion=null) {
	  modalMode = mode;
	  modalContext = { namespace, targetName: target, resourceVersion };
	  modalTitle.textContent = title;
	  modalBody.innerHTML = ''; // content filled by mode-specific loaders
	  modalOverlay.classList.remove('hidden');
	  // set the save handler appropriately
	  modalSaveBtn.onclick = () => {
	    if (modalMode === 'configmap-full') saveFullConfigMap();
	    else if (modalMode === 'deployment-full') saveFullDeployment();
	    else if (modalMode === 'replicas') saveReplicas();
	    else if (modalMode === 'cm-keys-edit') saveConfigMapKeyEdits();
	  };

	}
	function closeModal() {
	  modalOverlay.classList.add('hidden');
	  modalMode = null;
	  modalContext = { namespace: null, targetName: null, resourceVersion: null };
	  modalBody.innerHTML = '';
	}

	/* ---------------- Full notepad-style ConfigMap editor (uses fetchWithFallback) ---------------- */
	const cmRaw = {
	  name: null,
	  ns: 'default',
	  rv: '',
	  originalData: {},    // { key: string }
	  textarea: null
	};

	function esc(s){ return String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

	function computeChangedKeys(oldMap, newMap) {
	  const out = [];
	  const all = new Set([...Object.keys(oldMap), ...Object.keys(newMap)]);
	  for (const k of all) {
	    const a = oldMap[k] ?? '';
	    const b = newMap[k] ?? '';
	    if (a !== b) out.push({ key:k, oldVal:a, newVal:b });
	  }
	  return out.sort((x,y) => x.key.localeCompare(y.key));
	}

	function showDiffModal(changes) {
	  return new Promise(resolve => {
	    const overlay = document.createElement('div');
	    overlay.className = 'modal-overlay'; overlay.style.display = 'flex';
	    overlay.innerHTML = `
	      <div class="modal xlarge">
	        <div class="modal-header">
	          <h3>Review changes (${changes.length})</h3>
	          <button class="modal-close" id="diffCloseBtn">Ã—</button>
	        </div>
	        <div class="modal-body" style="max-height:65vh;overflow:auto;">
	          ${changes.map(ch => `
	            <div class="diff-block">
	              <div class="diff-key"><strong>${esc(ch.key)}</strong></div>
	              <div class="diff-grid">
	                <div class="diff-col"><div class="diff-title">Old</div><pre class="diff-pre">${esc(ch.oldVal)}</pre></div>
	                <div class="diff-col"><div class="diff-title">New</div><pre class="diff-pre">${esc(ch.newVal)}</pre></div>
	              </div>
	            </div>`).join('')}
	        </div>
	        <div class="modal-footer">
	          <button class="btn outline" id="diffCancelBtn">Cancel</button>
	          <button class="btn" id="diffConfirmBtn">Confirm & Save</button>
	        </div>
	      </div>`;
	    document.body.appendChild(overlay);
	    const done = ok => { overlay.remove(); resolve(ok); };
	    overlay.querySelector('#diffCloseBtn').onclick = () => done(false);
	    overlay.querySelector('#diffCancelBtn').onclick = () => done(false);
	    overlay.querySelector('#diffConfirmBtn').onclick = () => done(true);
	  });
	}

	// Open editor (loads full CM, shows only data as JSON)
	async function openFullConfigMap(namespace, name) {
	  openModal(`Edit ConfigMap â€” ${name}`, 'configmap-full', namespace, name, null);
	  modalBody.innerHTML = '<p style="color:var(--muted)">Loading ConfigMap...</p>';

	  const url = `/api/configmap/${encodeURIComponent(name)}/full?namespace=${encodeURIComponent(getNs())}`;
	  const res = await fetch(url);
	  if (!res.ok) {
	    const txt = await res.text().catch(()=>res.statusText);
	    modalBody.innerHTML = `<p style="color:var(--danger)">Load error (${res.status}): ${txt}</p>`;
	    return;
	  }
	  const payload = await res.json().catch(()=>null);
	  if (!payload) { modalBody.innerHTML = `<p style="color:var(--danger)">Malformed ConfigMap</p>`; return; }

	  cmRaw.name = name;
	  cmRaw.ns = getNs();
	  cmRaw.rv = payload.metadata?.resourceVersion || '';
	  cmRaw.originalData = payload.data || {};

	  // Sort keys for stable display
	  const sorted = Object.keys(cmRaw.originalData).sort()
	    .reduce((m,k)=> (m[k]=cmRaw.originalData[k], m), {});

	  modalBody.innerHTML = `
	    <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px;color:var(--muted);font-size:13px;">
	      <div><strong>${esc(name)}</strong> â€” ${esc(namespace)}</div>
	      <div style="margin-left:auto;">
	        <button id="cmDownloadBtn" class="btn outline small">Download</button>
	      </div>
	    </div>
	    <textarea id="cmRawTextarea" spellcheck="false"
	      style="width:100%;height:480px;padding:12px;font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,'Courier New',monospace;
	             font-size:13px;background:#0d1117;color:#e6eef6;border-radius:8px;border:1px solid rgba(255,255,255,0.06);resize:vertical;"></textarea>
	    <div style="margin-top:6px;color:var(--muted);font-size:12px;">
	      Tip: values must be strings. Weâ€™ll coerce numbers/booleans to strings on save.
	    </div>
	  `;
	  cmRaw.textarea = document.getElementById('cmRawTextarea');
	  cmRaw.textarea.value = JSON.stringify(sorted, null, 2);

	  // Download current data
	  document.getElementById('cmDownloadBtn').onclick = () => {
	    const blob = new Blob([JSON.stringify(sorted, null, 2)], { type: 'application/json' });
	    const href = URL.createObjectURL(blob);
	    const a = Object.assign(document.createElement('a'), { href, download: `${name}-configmap-data.json` });
	    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(href);
	  };

	  // Wire save
	  if (window.modalSaveBtn) {
	    modalSaveBtn.style.display = '';
	    modalSaveBtn.onclick = () => saveFullConfigMapRaw();
	  }
	}

	// Save (parse raw JSON, diff, PUT only data map)
	async function saveFullConfigMapRaw() {
	  const btn = window.modalSaveBtn || document.getElementById('saveFullCmBtn');
	  if (!cmRaw.textarea) { alert('Editor not found'); return; }

	  btn && (btn.disabled = true, btn.textContent = 'Validating...');

	  let parsed;
	  try {
	    parsed = JSON.parse(cmRaw.textarea.value);
	  } catch (e) {
	    alert('JSON parse error: ' + e.message);
	    btn && (btn.disabled = false, btn.textContent = 'Save');
	    return;
	  }

	  // Coerce values to strings (ConfigMap data values must be strings)
	  const newData = {};
	  for (const [k,v] of Object.entries(parsed)) {
	    newData[k] = (v == null) ? '' : String(v);
	  }

	  const changes = computeChangedKeys(cmRaw.originalData, newData);
	  if (changes.length === 0) {
	    alert('No changes to save.');
	    btn && (btn.disabled = false, btn.textContent = 'Save');
	    return;
	  }

	  const ok = await showDiffModal(changes);
	  if (!ok) { btn && (btn.disabled = false, btn.textContent = 'Save'); return; }

	  btn && (btn.textContent = 'Saving...');

	  try {
	    const url = `/api/configmap/${encodeURIComponent(cmRaw.name)}/full?namespace=${encodeURIComponent(cmRaw.ns)}${cmRaw.rv ? `&resourceVersion=${encodeURIComponent(cmRaw.rv)}` : ''}`;
	    const res = await fetch(url, {
	      method: 'PUT',
	      headers: { 'Content-Type': 'application/json' },
	      body: JSON.stringify(newData)
	    });
	    if (!res.ok) {
	      const txt = await res.text().catch(()=>res.statusText);
	      alert(`Save failed (${res.status}): ${txt}`);
	      return;
	    }
	    alert('ConfigMap saved.');
	    cmRaw.originalData = newData;   // refresh baseline
	    if (typeof closeModal === 'function') closeModal();
	    if (typeof fetchSummaryAndRender === 'function') fetchSummaryAndRender();
	  } catch (e) {
	    alert('Error: ' + e.message);
	  } finally {
	    btn && (btn.disabled = false, btn.textContent = 'Save');
	  }
	}

	// Open Logs /////// 
	
	function qp(obj) {
	  const u = new URLSearchParams();
	  Object.entries(obj).forEach(([k,v]) => {
	    if (v !== undefined && v !== null && v !== '' && v !== false) u.set(k, String(v));
	  });
	  const s = u.toString();
	  return s ? '?' + s : '';
	}

	async function openLogs(namespace, podName) {
	  const DEFAULT_LINES = 5000;
	  openModal(`Logs â€” ${podName}`, 'logs', namespace, podName, null);
	  modalBody.innerHTML = '<div style="color:var(--muted)">Loading containersâ€¦</div>';
	  if (window.modalSaveBtn) modalSaveBtn.style.display = 'none';

	  // 1) Fetch pod to discover containers
	  let pod;
	  try {
	    const res = await fetch(`/api/pods?namespace=${encodeURIComponent(getNs())}`);
	    const list = await res.json();
	    pod = Array.isArray(list) ? list.find(p => p?.metadata?.name === podName) : null;
	  } catch {}
	  const containers = (pod?.status?.containerStatuses || []).map(cs => cs?.name).filter(Boolean);
	  const initContainer = containers[0] || '';

	  // 2) Render controls
	  modalBody.innerHTML = `
	    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px;">
	      <label style="font-size:12px;color:var(--muted)">Container:</label>
	      <select id="logContainer" class="inp" style="min-width:180px;">
	        ${containers.length ? containers.map(n => `<option value="${n}">${n}</option>`).join('') : '<option value="">(single-container or unknown)</option>'}
	      </select>

	      <label style="font-size:12px;color:var(--muted);margin-left:12px;">Previous</label>
	      <input id="logPrevious" type="checkbox" />

	      <label style="font-size:12px;color:var(--muted);margin-left:12px;">sinceSeconds</label>
	      <input id="logSince" class="inp" type="number" min="0" placeholder="e.g. 600" style="width:110px;" />

	      <label style="font-size:12px;color:var(--muted);margin-left:12px;">lines</label>
	      <input id="logLines" class="inp" type="number" min="1" value="${DEFAULT_LINES}" style="width:110px;" />

	      <button id="logRefresh" class="btn" style="margin-left:auto;">Refresh</button>
	      <button id="logDownload" class="btn outline">Download</button>
	    </div>
	    <pre id="logsPre" style="max-height:65vh;overflow:auto;white-space:pre-wrap;background:#0d1117;color:#e6eef6;border:1px solid rgba(255,255,255,0.06);border-radius:8px;padding:10px;"></pre>
	  `;

	  const $container = document.getElementById('logContainer');
	  const $previous  = document.getElementById('logPrevious');
	  const $since     = document.getElementById('logSince');
	  const $lines     = document.getElementById('logLines');
	  const $refresh   = document.getElementById('logRefresh');
	  const $download  = document.getElementById('logDownload');
	  const $pre       = document.getElementById('logsPre');

	  if (initContainer) $container.value = initContainer;

	  async function loadLogs() {
	    $pre.textContent = 'Loadingâ€¦';
	    try {
	      const params = {
	        lines: $lines.value ? parseInt($lines.value, 10) : undefined,
	        sinceSeconds: $since.value ? parseInt($since.value, 10) : undefined,
	        container: $container.value || undefined,
	        previous: $previous.checked || undefined
	      };
	      const url = `/api/pods/${encodeURIComponent(getNs())}/${encodeURIComponent(podName)}/logs` + qp(params);
	      const res = await fetch(url, { headers: { 'Accept': 'text/plain' } });
	      const txt = await res.text();
	      if (!res.ok) {
	        $pre.textContent = `Load error (${res.status}): ${txt}`;
	        return;
	      }
	      // strip ANSI colors for readability
	      const clean = txt.replace(/\x1b\[[0-9;]*m/g, '');
	      $pre.textContent = clean;
	    } catch (e) {
	      $pre.textContent = 'Error: ' + e.message;
	    }
	  }

	  $refresh.onclick = loadLogs;
	  $download.onclick = () => {
	    const blob = new Blob([$pre.textContent || ''], { type: 'text/plain' });
	    const url = URL.createObjectURL(blob);
	    const a = document.createElement('a');
	    a.href = url; a.download = `${podName}${$container.value ? '-' + $container.value : ''}.log`;
	    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
	  };

	  // initial load
	  loadLogs();
	}

	
	async function saveFullConfigMapSmart() {
	  const btn = window.modalSaveBtn || document.getElementById('saveFullCmBtn');
	  btn && (btn.disabled = true, btn.textContent = 'Preparing diff...');

	  try {
	    const newData = (cmCtx.mode === 'raw-json') ? raw_collectData() : perKey_collectData();
	    const changes = computeChangedKeys(cmCtx.originalData, newData);

	    if (changes.length === 0) { alert('No changes to save.'); return; }

	    const ok = await showDiffModal(changes);
	    if (!ok) return;

	    btn && (btn.textContent = 'Saving...');

	    const url = `/api/configmap/${encodeURIComponent(cmCtx.name)}/full?namespace=${encodeURIComponent(cmCtx.ns)}${cmCtx.rv ? `&resourceVersion=${encodeURIComponent(cmCtx.rv)}` : ''}`;

	    const res = await fetch(url, {
	      method: 'PUT',
	      headers: { 'Content-Type': 'application/json' },
	      body: JSON.stringify(newData)   // only the data map
	    });

	    if (!res.ok) {
	      const txt = await res.text().catch(()=>res.statusText);
	      alert(`Save failed (${res.status}): ${txt}`);
	      return;
	    }

	    alert('ConfigMap saved.');
	    cmCtx.originalData = newData;     // refresh baseline
	    if (typeof closeModal === 'function') closeModal();
	    if (typeof fetchSummaryAndRender === 'function') fetchSummaryAndRender();
	  } catch (e) {
	    alert('Error: ' + e.message);
	  } finally {
	    if (btn) { btn.disabled = false; btn.textContent = 'Save'; }
	  }
	}



	/* ---------------- Replicas modal (tries multiple endpoints) ---------------- */
	function openReplicasModal(namespace, deploymentName) {
	  openModal(`Set Replicas â€” ${deploymentName}`, 'replicas', namespace, deploymentName, null);

	  modalBody.innerHTML = `
	    <div id="replicasPanel">
	      <div style="margin-bottom:10px;">
	        <label class="lbl">Deployment</label>
	        <input id="deploySelect" class="inp" value="${deploymentName}" readonly />
	      </div>
	      <div>
	        <label class="lbl">Replicas</label>
	        <input id="replicaInput" class="inp" type="number" min="0" step="1" placeholder="e.g. 2" />
	      </div>
	    </div>
	  `;

	  // Prevent accidental form submits (if any ancestor is a form)
	  modalSaveBtn.setAttribute('type', 'button');

	  // Hitting Enter in the replicas input should NOT submit a form
	  const ri = document.getElementById('replicaInput');
	  ri.addEventListener('keydown', (e) => {
	    if (e.key === 'Enter') {
	      e.preventDefault();
	      saveReplicas();
	    }
	  });
	}


	/* ---------------- Deployment editor: open + save ---------------- */
	async function openFullDeployment(namespace, name) {
	  openModal(`Edit Deployment â€” ${name}`, 'deployment-full', namespace, name, null);
	  modalBody.innerHTML = '<p style="color:var(--muted)">Loading deployment...</p>';

	  // sensible candidate list; avoid list-style /api/deployments/... shapes that produce 404 static resource errors
	  const candidates = [
	      `/api/deployments/${encodeURIComponent(getNs())}/${encodeURIComponent(name)}`
	    ];

	  const result = await fetchWithFallback(candidates);
	  if (!result.res) {
	    modalBody.innerHTML = `<p style="color:var(--danger)">Deployment '${name}' not found (tried multiple endpoints).</p>`;
	    console.info('openFullDeployment: none matched', candidates);
	    return;
	  }
	  console.info('openFullDeployment: used endpoint', result.url);

	  if (!result.res.ok) {
	    const txt = await result.res.text().catch(()=>result.res.statusText);
	    modalBody.innerHTML = `<p style="color:var(--danger)">Load error (${result.res.status}): ${txt}</p>`;
	    return;
	  }

	  let payload;
	  try {
	    payload = await result.res.json();
	  } catch (err) {
	    modalBody.innerHTML = `<p style="color:var(--danger)">Malformed JSON from ${result.url}</p>`;
	    return;
	  }

	  modalContext.resourceVersion = payload.metadata?.resourceVersion || null;
	  const text = JSON.stringify(payload || {}, null, 2);
	  modalBody.innerHTML = `
	    <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;">
	      <div style="color:var(--muted);font-size:13px;">Replica target: ${payload.spec?.replicas ?? '-'}</div>
	      <div style="margin-left:auto"><button class="btn outline" id="downloadDeployBtn">Download</button></div>
	    </div>
	    <textarea id="fullDeploymentTextarea" spellcheck="false" style="width:100%;height:420px;padding:12px;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Courier New', monospace; font-size:13px; background:var(--panel); color:#e6eef6; border-radius:8px; border:1px solid rgba(255,255,255,0.04);"></textarea>
	  `;
	  document.getElementById('fullDeploymentTextarea').value = text;
	  document.getElementById('downloadDeployBtn').onclick = () => {
	    const blob = new Blob([document.getElementById('fullDeploymentTextarea').value], { type: 'application/json' });
	    const url = URL.createObjectURL(blob);
	    const a = document.createElement('a'); a.href = url; a.download = `${name}-deployment.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
	  };
	}


	async function saveFullDeployment() {
	  const ta = document.getElementById('fullDeploymentTextarea');
	  if (!ta) return alert('Deployment editor not found');
	  let parsed;
	  try {
	    parsed = JSON.parse(ta.value);
	  } catch (err) {
	    alert('JSON parse error: ' + err.message);
	    return;
	  }

	  parsed.metadata = parsed.metadata || {};
	  parsed.metadata.name = parsed.metadata.name || modalContext.targetName;
	  parsed.metadata.namespace = parsed.metadata.namespace || modalContext.namespace;

	  const body = JSON.stringify(parsed, null, 2);
	  const url = `/api/deployments/${encodeURIComponent(getNs())}/${encodeURIComponent(modalContext.targetName)}`;

	  modalSaveBtn.disabled = true;
	  modalSaveBtn.textContent = 'Saving...';

	  try {
	    const res = await fetch(url, {
	      method: 'PUT',
	      headers: { 'Content-Type': 'application/json' },
	      body
	    });

	    if (!res.ok) {
	      const msg = await res.text().catch(() => res.statusText);
	      alert(`Save failed (${res.status}): ${msg}`);
	    } else {
	      alert('Deployment updated successfully.');
	      closeModal();
	      fetchSummaryAndRender();
	    }
	  } catch (err) {
	    alert('Error saving deployment: ' + err.message);
	  } finally {
	    modalSaveBtn.disabled = false;
	    modalSaveBtn.textContent = 'Save';
	  }
	}




	async function saveReplicas() {
	  const deploy = document.getElementById('deploySelect')?.value;
	  const replicas = parseInt(document.getElementById('replicaInput')?.value, 10);

	  if (!deploy) { alert('No deployment selected.'); return; }
	  if (Number.isNaN(replicas)) { alert('Specify a valid number.'); return; }

	  modalSaveBtn.disabled = true;
	  modalSaveBtn.textContent = 'Scaling...';

	  try {
	    const encNS = encodeURIComponent(getNs());
	    const encDeploy = encodeURIComponent(deploy);
	    const url = `/api/deployments/${encNS}/${encDeploy}/scale`;

	    const res = await fetch(url, {
	      method: 'POST',
	      headers: { 'Content-Type': 'application/json' },
	      body: JSON.stringify({ replicas })
	    });

	    if (!res.ok) {
	      const body = await res.text().catch(() => res.statusText);
	      alert('Scale failed: ' + res.status + ' ' + body);
	    } else {
	      alert('Scale request accepted.');
	      closeModal();
	      fetchSummaryAndRender?.();
	    }
	  } catch (err) {
	    alert('Error scaling: ' + err.message);
	  } finally {
	    modalSaveBtn.disabled = false;
	    modalSaveBtn.textContent = 'Save';
	  }
	}




	/* ---------------- Modal close wiring ---------------- */
	document.addEventListener('click', function (e) {
	  if (e.target && e.target.matches && e.target.matches('.modal-close')) {
	    closeModal();
	  }
	});
	document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !modalOverlay.classList.contains('hidden')) closeModal(); });

	/* ---------------- Event bindings & init ---------------- */
	refreshBtn.addEventListener('click', async () => {
	  const ns = (namespaceSelect?.value) || 'default';
	  // Optional: show immediate UI feedback
	  const originalText = refreshBtn.textContent;
	  try {
	    refreshBtn.disabled = true;
	    refreshBtn.textContent = 'Auth...';
	    // Call backend to run the login script with the namespace
	    const res = await fetch(`/api/run-login-script?namespace=${encodeURIComponent(ns)}`, { method: 'POST' });
	    const payload = await res.json().catch(()=>null);

	    if (!res.ok) {
	      console.error('login script failed', payload);
	      alert('Cluster login failed: ' + (payload?.error || payload?.stderr || 'unknown error'));
	      return; // stop further refresh
	    }

	    // Optionally show stdout in console
	    console.info('login script output', payload?.stdout);

	    // Now kubeconfig should be updated â€” continue with normal refresh
	    refreshBtn.textContent = 'Refreshing...';
	    await fetchSummaryAndRender();
	  } catch (err) {
	    console.error('error running login script', err);
	    alert('Failed to run login script: ' + err.message);
	  } finally {
	    refreshBtn.disabled = false;
	    refreshBtn.textContent = originalText;
	  }
	});

	if (searchInput) searchInput.addEventListener('input', () => { clearTimeout(window.__pod_search_timer); window.__pod_search_timer = setTimeout(fetchSummaryAndRender, 180); });
	if (namespaceSelect) namespaceSelect.addEventListener('change', () => { currentNamespace = namespaceSelect.value; fetchSummaryAndRender(); });

	// Defer startup until env/ns chosen
    async function startApp() {
      try {
        updateCardActiveState();
        await fetchSummaryAndRender();
        //if (!window.__pods_poll) window.__pods_poll = setInterval(fetchSummaryAndRender, 5000);
        const main = document.getElementById('mainContent');
        if (main) main.style.visibility = 'visible';
      } catch(e) {
        console.warn('startApp failed', e);
      }
    }
	
	
	  // Injected from server (no API call)
	  const ENV_MAP = /*[[${envConfigJson}]]*/ '{}';

	    let ENV_DATA = {};
        (function loadEnvData(){
          try {
            if (window.KDASH_ENV_MAP && typeof window.KDASH_ENV_MAP === 'object') {
              ENV_DATA = window.KDASH_ENV_MAP;
              return;
            }
          } catch (e) {}
          try {
            const raw = document.getElementById('env-data')?.textContent?.trim();
            if (raw && raw !== '[[${envConfigJson}]]') {
              ENV_DATA = JSON.parse(raw);
            }
          } catch (e) {
            console.warn('ENV_DATA parse failed', e);
            ENV_DATA = {};
          }
        })();

	    const els = {
	      modal: document.getElementById('envModal'),
	      env: document.getElementById('envSelect'),
	      ns: document.getElementById('nsSelect'),
	      apply: document.getElementById('envApplyBtn'),
	      cancel: document.getElementById('envCancelBtn'),
	      switchBtn: document.getElementById('switchEnvBtn'),
	    };

	    // --- Renamed to avoid clashing with the app modal ---
		let _lastFocus = null;

		function openEnvModal() {
		  const overlay = document.getElementById('envModal');
		  _lastFocus = document.activeElement;
		  overlay.classList.remove('hidden'); overlay.removeAttribute('inert');
		  overlay.setAttribute('aria-hidden', 'false');
		  setTimeout(() => document.getElementById('envSelect')?.focus(), 0);
		}

		function closeEnvModal() {
		  const overlay = document.getElementById('envModal');
		  overlay.classList.add('hidden'); overlay.setAttribute('inert','');
		  overlay.setAttribute('aria-hidden', 'true');
		  _lastFocus?.focus();
		}



	    function populateEnvs(selected) {
	      els.env.innerHTML = '<option value="" disabled selected>Select environmentâ€¦</option>';
	      Object.keys(ENV_DATA).forEach(env => {
	        const opt = document.createElement('option');
	        opt.value = env; opt.textContent = env;
	        if (selected && selected === env) opt.selected = true;
	        els.env.appendChild(opt);
	      });
	    }

	    function populateNamespaces(env, selectedNs) {
	      const list = ENV_DATA[env] || [];
	      els.ns.innerHTML = '';
	      if (!env || list.length === 0) {
	        els.ns.disabled = true;
	        els.apply.disabled = true;
	        return;
	      }
	      list.forEach(ns => {
	        const opt = document.createElement('option');
	        opt.value = ns; opt.textContent = ns;
	        if (selectedNs && selectedNs === ns) opt.selected = true;
	        els.ns.appendChild(opt);
	      });
	      els.ns.disabled = false;
	      els.apply.disabled = !els.ns.value;
	    }

	    const KEY_ENV = 'kdash.selected.env';
	    const KEY_NS  = 'kdash.selected.ns';
	    const loadSaved = () => ({ env: localStorage.getItem(KEY_ENV) || '', ns: localStorage.getItem(KEY_NS) || '' });
	    const save = (env, ns) => (localStorage.setItem(KEY_ENV, env), localStorage.setItem(KEY_NS, ns));

	    function applySelection() {
	      const env = els.env.value;
	      const ns  = els.ns.value;
	      if (!env || !ns) return;

	      save(env, ns);
	      closeEnvModal();

	      // Start in-page without reload
          const badge = document.querySelector('#currentEnvNs');
          if (badge) badge.textContent = `${env} / ${ns}`;
          window.currentNamespace = ns;
          const main = document.getElementById('mainContent');
          if (main) { main.style.display = ''; main.style.visibility = 'visible'; }
          window.__envReady = true;
          if (typeof fetchSummaryAndRender === 'function') fetchSummaryAndRender();
          if (typeof startApp === 'function') startApp();
	    }

	    // Button to open the modal
	    els.switchBtn?.addEventListener('click', () => {
	      const saved = loadSaved();
	      populateEnvs(saved.env || '');
	      populateNamespaces(saved.env || '', saved.ns || '');
	      openEnvModal();
	    });

	    els.env.addEventListener('change', () => populateNamespaces(els.env.value, ''));
	    els.ns.addEventListener('change', () => { els.apply.disabled = !(els.env.value && els.ns.value); });
	    els.apply.addEventListener('click', applySelection);
	    els.cancel.addEventListener('click', closeEnvModal);

	    // First load: if nothing saved, show startup modal
	    document.addEventListener('DOMContentLoaded', () => {
      const saved = loadSaved();
			  const badge = document.querySelector('#currentEnvNs');

			  // Preselect if saved, but DO NOT start the app yet.
			  if (saved.env && saved.ns) {
			    badge && (badge.textContent = `${saved.env} / ${saved.ns}`);
			  }

			  // Populate & open modal once (no duplicates)
			  populateEnvs(saved.env || '');
			  populateNamespaces(saved.env || '', saved.ns || '');
			  openEnvModal();

			  // Keep content hidden and do not fetch anything yet.
			  const main = document.getElementById('mainContent');
			  if (main) { main.style.display = 'none'; main.style.visibility = 'hidden'; }

			  // Optional: allow URL override to prefill the modal only
			  const params = new URLSearchParams(window.location.search);
			  const urlEnv = params.get('env');
			  const urlNs  = params.get('namespace');
			  if (urlEnv && urlNs) {
			    save(urlEnv, urlNs);
			    badge && (badge.textContent = `${urlEnv} / ${urlNs}`);
			  }
			});
	
</script>

<script src="/js/kdash_on_demand_patch.js"></script>
<script>
(function () {
  const nsSel = document.getElementById('namespaceSelect');
  const ids = {
    running:  '#count-running',
    pending:  '#count-pending',
    abnormal: '#count-abnormal',
    services: '#count-services-zero'
  };

  const setText = (sel, n) => {
    const el = document.querySelector(sel);
    if (el) el.textContent = String(n);
  };
  const normPhase = (p) => ((p?.status?.phase || p?.status || '') + '').toLowerCase();
  const isAbnormal = (p) => (p?.status?.containerStatuses || []).some(c => {
    const w = (c?.state?.waiting?.reason || '').toLowerCase();
    const t = (c?.state?.terminated?.reason || '').toLowerCase();
    return w.includes('crashloop') || w.includes('error') || t.includes('error') || t.includes('crash');
  });


  async function refreshCardCounts() {
    const ns = getNs();
    const t = Date.now();
    try {
      const [podsRes, svcRes] = await Promise.all([
        fetch(`/api/pods?namespace=${encodeURIComponent(ns)}&t=${t}`, { cache: 'no-store' }),
        // prefer your backend endpoint; if you don't expose it, it will 404 and we treat as 0
        fetch(`/api/services/zero?namespace=${encodeURIComponent(ns)}&t=${t}`, { cache: 'no-store' }).catch(() => null)
      ]);

      // Pods â†’ compute running/pending/abnormal counts
      const podsPayload = podsRes.ok ? await podsRes.json() : [];
      const pods = Array.isArray(podsPayload) ? podsPayload
                 : (podsPayload && Array.isArray(podsPayload.items) ? podsPayload.items : []);

      setText(ids.running,  pods.filter(p => normPhase(p).includes('running')).length);
      setText(ids.pending,  pods.filter(p => {
        const s = normPhase(p);
        return s.includes('pending') || s.includes('containercreating');
      }).length);
      setText(ids.abnormal, pods.filter(isAbnormal).length);

      // Services (0 pods) â†’ use endpoint if present, else show 0 (still clickable to compute list on demand)
      let zeroCount = 0;
      if (svcRes && svcRes.ok) {
        const svcPayload = await svcRes.json();
        const arr = Array.isArray(svcPayload) ? svcPayload : (svcPayload?.items || []);
        zeroCount = arr.length;
      }
      setText(ids.services, zeroCount);

    } catch (e) {
      console.error('refreshCardCounts error', e);
      // donâ€™t throw; just keep previous numbers
    }
  }

  // Expose in case you want to call it manually
  window.refreshCardCounts = refreshCardCounts;

  // Kick once and set a **summary-only** poller (does not touch podsBody nor detail rows)
  try { if (window.__summary_poll) clearInterval(window.__summary_poll); } catch {}
  refreshCardCounts();
  window.__summary_poll = setInterval(refreshCardCounts, 10000); // 10s; tune as you like

  // Also refresh counts when namespace changes
  if (nsSel) nsSel.addEventListener('change', refreshCardCounts);
})();
</script>

<script>
// --- Option A: POST /api/run-login-script on Apply ---
(function(){
  function ensureToast(){
    let t = document.getElementById('kdashToast');
    if (t) return t;
    t = document.createElement('div');
    t.id = 'kdashToast';
    t.style.cssText = 'position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:8px 12px;border-radius:8px;opacity:0;transition:opacity .2s;z-index:9999;font-size:13px';
    document.body.appendChild(t);
    return t;
  }
  function toast(msg, ok){
    const t = ensureToast();
    t.textContent = msg;
    t.style.background = ok ? '#176b3a' : '#8a1c1c';
    t.style.opacity = '1';
    setTimeout(()=>{ t.style.opacity = '0'; }, 2200);
  }

  // Callable from anywhere
  window.runLoginScript = async function runLoginScript(){
    const envSel = document.getElementById('envSelect');
    const nsSel  = document.getElementById('namespaceSelect') || document.getElementById('nsSelect');
    const environment = envSel && envSel.value && envSel.value !== 'select' ? envSel.value : null;
    const namespace   = nsSel && nsSel.value && nsSel.value !== 'all' ? nsSel.value : null;
    if (!environment || !namespace) { toast('Choose both environment and namespace', false); return false; }

    try {
      const res = await fetch('/api/run-login-script', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ environment, namespace }),
        cache: 'no-store'
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=>res.statusText);
        toast(`Login script failed (${res.status}): ${txt}`, false);
        return false;
      }
      toast('Login script executed âœ”', true);
      return true;
    } catch (e) {
      toast('Login script error: ' + (e.message || e), false);
      return false;
    }
  };

  // Wire Apply -> runLoginScript
  const btn = document.getElementById('envApplyBtn');
  if (btn) {
    btn.addEventListener('click', async () => {
      const ok = await window.runLoginScript();
      if (ok) {
        if (typeof window.closeEnvModal === 'function') closeEnvModal();
        if (typeof window.fetchSummaryAndRender === 'function') fetchSummaryAndRender();
      }
    }, { passive: true });
  }
})();
</script>


  </div>
</div>

</html>