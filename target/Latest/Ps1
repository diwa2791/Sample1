package com.example.compare;

import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Service;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@EnableAsync
@Controller
@RequestMapping("/compare")
public class TableCompareAsyncModule {

    private final CompareService service;

    public TableCompareAsyncModule(CompareService service) {
        this.service = service;
    }

    /* ================= PAGE ================= */

    @GetMapping
    public String page() {
        return "compare";
    }

    /* ================= START JOB ================= */

    @PostMapping("/start")
    public String start(CompareRequest req, Model model) {

        String jobId = service.startAsyncComparison(req);

        model.addAttribute("jobId", jobId);
        return "progress";
    }

    /* ================= PROGRESS API ================= */

    @GetMapping("/progress/{jobId}")
    @ResponseBody
    public JobStatus progress(@PathVariable String jobId) {
        return service.getStatus(jobId);
    }

    /* ================= VIEW RESULT ================= */

    @GetMapping("/view")
    public String view(
            String cacheId,
            @RequestParam(defaultValue = "modified") String type,
            @RequestParam(defaultValue = "0") int page,
            Model model) {

        model.addAttribute("data",
                service.getPage(cacheId, type, page));

        return "compare";
    }
}

/* ==========================================================
   SERVICE
   ========================================================== */

@Service
class CompareService {

    private static final int PAGE_SIZE = 1000;
    private static final long TTL = 15 * 60 * 1000;

    private final Map<String, CachedResult> resultCache = new ConcurrentHashMap<>();
    private final Map<String, JobStatus> jobs = new ConcurrentHashMap<>();

    /* ================= START ASYNC ================= */

    public String startAsyncComparison(CompareRequest req) {

        String jobId = UUID.randomUUID().toString();

        jobs.put(jobId, new JobStatus("RUNNING", 0, null));

        runComparisonAsync(jobId, req);

        return jobId;
    }

    /* ================= ASYNC JOB ================= */

    @Async
    public void runComparisonAsync(String jobId, CompareRequest req) {

        try {

            // simulate steps
            update(jobId, 10);

            Thread.sleep(1000);

            update(jobId, 30);

            Thread.sleep(1000);

            update(jobId, 60);

            // ðŸ”¥ Replace with REAL SQL comparison
            TableDiffResult result = mockDiff();

            update(jobId, 90);

            String cacheId = UUID.randomUUID().toString();
            resultCache.put(cacheId, new CachedResult(result));

            jobs.put(jobId,
                    new JobStatus("DONE", 100, cacheId));

        } catch (Exception e) {
            jobs.put(jobId,
                    new JobStatus("FAILED", 0, null));
        }
    }

    private void update(String id, int progress) {
        jobs.put(id,
                new JobStatus("RUNNING", progress, null));
    }

    /* ================= STATUS ================= */

    public JobStatus getStatus(String jobId) {
        return jobs.get(jobId);
    }

    /* ================= PAGINATION ================= */

    public PagedResponse getPage(String cacheId, String type, int page) {

        cleanup();

        TableDiffResult data = resultCache.get(cacheId).data;

        List<RowDiff> source =
                switch (type) {
                    case "modified" -> data.modified;
                    case "test" -> data.onlyTest;
                    case "prod" -> data.onlyProd;
                    default -> List.of();
                };

        int start = page * PAGE_SIZE;
        int end = Math.min(start + PAGE_SIZE, source.size());

        return new PagedResponse(
                cacheId,
                type,
                page,
                PAGE_SIZE,
                source.size(),
                source.subList(start, end),
                data.summary
        );
    }

    private void cleanup() {
        long now = System.currentTimeMillis();
        resultCache.entrySet()
                .removeIf(e -> now - e.getValue().createdAt > TTL);
    }

    /* ================= MOCK DATA ================= */

    private TableDiffResult mockDiff() {

        List<RowDiff> modified = new ArrayList<>();

        for (int i = 1; i <= 5000; i++) {
            modified.add(
                    RowDiff.modified(
                            Map.of("id", i),
                            List.of(new ColumnDiff("salary", 100, 200))
                    ));
        }

        return new TableDiffResult(
                modified,
                List.of(),
                List.of(),
                new Summary(5000,0,0)
        );
    }
}

/* ==========================================================
   CACHE
   ========================================================== */

class CachedResult {
    TableDiffResult data;
    long createdAt = System.currentTimeMillis();
    CachedResult(TableDiffResult d){data=d;}
}

/* ==========================================================
   DTOs
   ========================================================== */

class CompareRequest {
    private String tableName;
    public String getTableName(){return tableName;}
    public void setTableName(String t){tableName=t;}
}

class JobStatus {
    public String status;
    public int progress;
    public String cacheId;

    JobStatus(String s,int p,String c){
        status=s;progress=p;cacheId=c;
    }
}

class PagedResponse {
    public String cacheId,type;
    public int page,pageSize,totalRows;
    public List<RowDiff> rows;
    public Summary summary;

    PagedResponse(String id,String t,int p,int ps,int total,
                  List<RowDiff> r,Summary s){
        cacheId=id;type=t;page=p;
        pageSize=ps;totalRows=total;rows=r;summary=s;
    }
}

class TableDiffResult {
    List<RowDiff> modified,onlyTest,onlyProd;
    Summary summary;

    TableDiffResult(List<RowDiff> m,List<RowDiff> t,
                    List<RowDiff> p,Summary s){
        modified=m;onlyTest=t;onlyProd=p;summary=s;
    }
}

class RowDiff {
    Map<String,Object> primaryKey;
    List<ColumnDiff> changedColumns;

    static RowDiff modified(Map<String,Object> pk,List<ColumnDiff> c){
        RowDiff r=new RowDiff();
        r.primaryKey=pk;
        r.changedColumns=c;
        return r;
    }
}

class ColumnDiff {
    public String columnName;
    public Object testValue,prodValue;
    ColumnDiff(String c,Object t,Object p){
        columnName=c;testValue=t;prodValue=p;
    }
}

class Summary {
    public long different,onlyTest,onlyProd;
    Summary(long d,long t,long p){
        different=d;onlyTest=t;onlyProd=p;
    }
}
