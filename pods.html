<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <base href="/" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pods - K8s Dashboard</title>

  <link rel="stylesheet" href="/css/styles.css" />
  <script src="/js/sidebar.js" defer></script>
</head>

<body data-page="pods">
  <!-- Sidebar placeholder: we will load /fragments/sidebar.html into this -->
  <div id="sidebar-placeholder"></div>

  <!-- Topbar (static, no Thymeleaf) -->
  <header class="topbar">
    <div class="brand">K8s Dashboard</div>
    <div class="controls">
      <label for="namespaceSelect" style="color:#aab7c6;margin-right:6px;font-size:13px;">Namespace:</label>
      <select id="namespaceSelect"></select>
      <input id="search" type="text" placeholder="Search..." />
      <button id="refreshBtn">Refresh</button>
    </div>
  </header>

  <!-- Main content -->
  <main class="container" id="mainContent">
    <!-- Summary -->
    <section class="summary">
      <div class="card card-filter" id="card-running" data-filter="Running">
        <div class="card-title">Running (1/1)</div>
        <div id="count-running" class="card-value">0</div>
      </div>
      <div class="card card-filter" id="card-pending" data-filter="Pending">
        <div class="card-title">Pending (Creating)</div>
        <div id="count-pending" class="card-value">0</div>
      </div>
      <div class="card card-filter" id="card-abnormal" data-filter="Abnormal">
        <div class="card-title">Abnormal</div>
        <div id="count-abnormal" class="card-value">0</div>
      </div>
      <div class="card card-filter" id="card-services-zero" data-filter="ServicesZero">
        <div class="card-title">Services (0 pods)</div>
        <div id="count-services-zero" class="card-value">0</div>
      </div>
    </section>

    <!-- Pods Table -->
    <section class="table-wrap">
      <table id="podsTable">
        <thead>
          <tr>
            <th style="width:52%;">Name</th>
            <th>Status</th>
            <th>Age</th>
            <th style="width:240px;">Actions</th>
          </tr>
        </thead>
        <tbody id="podsBody"></tbody>
      </table>
    </section>
  </main>

  <!-- Shared modal overlay (as in your previous file) -->
  <div id="modalOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modalTitle">Edit</h3>
        <button class="modal-close" onclick="closeModal()">×</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer">
        <button class="btn outline" onclick="closeModal()">Cancel</button>
        <button class="btn" id="modalSaveBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- Full ConfigMap Editor Modal -->
  <div id="fullCmOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal large">
      <div class="modal-header">
        <h3 id="fullCmTitle">Edit ConfigMap</h3>
        <button class="modal-close" onclick="closeFullCm()">×</button>
      </div>

      <div class="modal-meta" style="display:flex;gap:12px;align-items:center;margin-bottom:8px;">
        <div id="fullCmInfo" style="color:var(--muted);font-size:13px"></div>
        <div style="margin-left:auto;">
          <button class="btn outline" id="downloadCmBtn">Download</button>
        </div>
      </div>

      <div class="modal-body" style="padding:0;">
        <textarea id="fullCmTextarea" spellcheck="false"
          style="width:100%;height:420px;padding:12px;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Courier New', monospace; font-size:13px; background:var(--panel); color:#e6eef6; border:none; resize:vertical;"></textarea>
      </div>

      <div class="modal-footer">
        <button class="btn outline" onclick="closeFullCm()">Cancel</button>
        <button class="btn" id="saveFullCmBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- ========== Script: load sidebar fragment, then run your existing page logic ========== -->
  <script>
    // Load /fragments/sidebar.html into #sidebar-placeholder
    (async function loadSidebar() {
      try {
        const res = await fetch('/fragments/sidebar.html', { cache: 'no-store' });
        if (res.ok) {
          const html = await res.text();
          document.getElementById('sidebar-placeholder').innerHTML = html;
          // sidebar.js will run (it is loaded with defer), but if your fragment had scripts we would re-attach them here.
        } else {
          // Minimal fallback
          document.getElementById('sidebar-placeholder').innerHTML = `
            <nav class="sidebar"><div class="sidebar-inner">
              <ul class="nav">
                <li><a href="/pods.html" class="nav-link">Pods</a></li>
                <li><a href="/services.html" class="nav-link">Services</a></li>
                <li><a href="/deployments.html" class="nav-link">Deployments</a></li>
              </ul>
            </div></nav>`;
        }
      } catch {
        /* ignore */
      }
    })();
	/* ---------------- Globals & DOM refs ---------------- */
	const podsBody = document.getElementById('podsBody');
	const searchInput = document.getElementById('search');
	const refreshBtn = document.getElementById('refreshBtn');
	const namespaceSelect = document.getElementById('namespaceSelect');

	let currentNamespace = 'all';
	let statusFilter = null; // Running | Pending | Abnormal | ServicesZero

	// Summary card elements
	const cardEls = {
	  running: document.getElementById('card-running'),
	  pending: document.getElementById('card-pending'),
	  abnormal: document.getElementById('card-abnormal'),
	  servicesZero: document.getElementById('card-services-zero')
	};

	// Modal shared elements (already exist in your page)
	const modalOverlay = document.getElementById('modalOverlay');
	const modalTitle = document.getElementById('modalTitle');
	const modalBody = document.getElementById('modalBody');
	const modalSaveBtn = document.getElementById('modalSaveBtn');

	/* modal mode state:
	   - null = closed
	   - 'configmap-full' = full notepad editor (modalBody will contain textarea#fullCmTextarea)
	   - 'replicas' = replicas UI (modalBody contains select/input)
	*/
	let modalMode = null;
	let modalContext = { namespace: null, targetName: null, resourceVersion: null };

	/* ---------------- Helper: derive service/configmap name from pod name ---------------- */
	// Removes the last two hyphen-separated segments (typical pod suffixes).
	function baseServiceNameFromPod(podName) {
	  if (!podName || typeof podName !== 'string') return podName;
	  const parts = podName.split('-');
	  if (parts.length > 2) return parts.slice(0, -2).join('-');
	  return podName;
	}
	
	// Return the Kubernetes phase ("Running", "Pending", "Failed", etc.)
	function podPhase(pod) {
	  const s = pod?.status;
	  if (!s) return '-';
	  // Phase comes from status.phase; fall back safely if someone put a string in status
	  return (typeof s === 'object' && s.phase) ? s.phase : String(s);
	}

	// Return {ready, total} from containerStatuses, or null if unavailable
	function podReadyCounts(pod) {
	  const statuses = pod?.status?.containerStatuses;
	  if (!Array.isArray(statuses)) return null;
	  const total = statuses.length;
	  const ready = statuses.reduce((acc, cs) => acc + (cs?.ready ? 1 : 0), 0);
	  return { ready, total };
	}

	// Build a friendly label like "Running (1/1)" or "Pending (0/1)"
	function podStatusLabel(pod) {
	  const phase = podPhase(pod) || '-';
	  const counts = podReadyCounts(pod);
	  if (counts && counts.total > 0) {
	    return `${phase} (${counts.ready}/${counts.total})`;
	  }
	  return phase;
	}

	// Lowercase phase for filtering/sorting
	function normalizePodStatus(pod) {
	  return podPhase(pod).toLowerCase();
	}

	// Optional: badge class by phase
	function badgeClassFor(pod) {
	  const phase = normalizePodStatus(pod);
	  if (phase === 'running') return 'badge ok';
	  if (phase === 'pending' || phase.includes('creating')) return 'badge warn';
	  if (phase === 'failed' || phase.includes('crash')) return 'badge danger';
	  return 'badge';
	}



	/* ---------------- Small utility: try multiple fetch endpoints ---------------- */
	/**
	 * candidates: array of URL strings
	 * returns: { res: Response, url: string } on first OK, or { res: lastNonOkResponse | null, url: attemptedUrl | null } if none OK
	 */
	 async function fetchWithFallback(candidates) {
	   let lastNonOk = null;
	   const tried = [];
	   for (const url of candidates) {
	     tried.push(url);
	     try {
	       const r = await fetch(url);
	       if (r.ok) {
	         console.info('fetchWithFallback: success', url);
	         return { res: r, url };
	       }
	       lastNonOk = { res: r, url };
	       if (r.status === 404) continue;
	       return { res: r, url };
	     } catch (err) {
	       console.warn('fetch candidate failed', url, err);
	       continue;
	     }
	   }
	   console.info('fetchWithFallback: none matched. tried:', tried);
	   return lastNonOk || { res: null, url: null };
	 }



	/* ---------------- Summary card filter wiring ---------------- */
	Object.values(cardEls).forEach(el => {
	  el.addEventListener('click', () => {
	    const f = el.dataset.filter;
	    statusFilter = (statusFilter === f) ? null : f;
	    updateCardActiveState();
	    fetchSummaryAndRender();
	  });
	});
	function updateCardActiveState() {
	  Object.values(cardEls).forEach(el => el.classList.toggle('active', statusFilter === el.dataset.filter));
	}

	/* ---------------- Pod table rendering ---------------- */
	// Replace/insert this function in your script
	function createPodRow(p) {
	  // p is expected to be an object with at least: name, status, age, namespace (optional)
	  const ns = p.namespace || currentNamespace || 'default';
	  const podName = p.name || (p.metadata && p.metadata.name) || 'unknown-pod';
	  const deployName = baseServiceNameFromPod(podName);

	  const tr = document.createElement('tr');

	  // Name cell
	  const nameTd = document.createElement('td');
	  nameTd.innerHTML = `<strong>${podName}</strong><div class="text-muted small">${ns}</div>`;

	  // Status cell
	  const statusTd = document.createElement('td');
	  const badge = document.createElement('span');
	  badge.className = badgeClassFor(p);              // e.g., "badge ok" / "badge warn" / "badge danger"
	  badge.textContent = podStatusLabel(p);           // e.g., "Running (1/1)"
	  statusTd.appendChild(badge);


	  // Age cell
	  const ageTd = document.createElement('td');
	  ageTd.textContent = p.age || (p.metadata && p.metadata.creationTimestamp ? isoAge(p.metadata.creationTimestamp) : '-');

	  // Actions cell
	  const actionsTd = document.createElement('td');

	  // Helper to create buttons quickly
	  const makeBtn = (text, cls = 'btn', onClick) => {
	    const b = document.createElement('button');
	    b.className = cls;
	    b.textContent = text;
	    b.onclick = onClick;
	    return b;
	  };

	  // Logs
	  actionsTd.appendChild(makeBtn('Logs', 'btn outline small', () => openLogs(ns, podName)));


	  // Restart
	  actionsTd.appendChild(makeBtn('Restart', 'btn outline', async () => {
	    if (confirm(`Delete pod ${podName} to force restart?`)) {
	      await restartPod(ns, podName);
	      fetchSummaryAndRender();
	    }
	  }));

	  // Edit ConfigMap (derive name from deployment)
	  actionsTd.appendChild(makeBtn('Edit ConfigMap', 'btn outline small', async () => {
	    await openFullConfigMap(ns, deployName);
	  }));

	  // Edit Deployment (new)
	  actionsTd.appendChild(makeBtn('Edit Deployment', 'btn outline small', async () => {
	    await openFullDeployment(ns, deployName);
	  }));

	  // Set Replicas (open replicas modal; pass deployment name)
	  actionsTd.appendChild(makeBtn('Set Replicas', 'btn outline small', async () => {
	    openReplicasModal(ns, deployName); // or service-derived name
	  }));


	  tr.appendChild(nameTd);
	  tr.appendChild(statusTd);
	  tr.appendChild(ageTd);
	  tr.appendChild(actionsTd);
	  return tr;
	}

	
	// Convert an ISO timestamp (e.g. 2025-10-19T11:57:45Z) into a human-readable age like "3h" or "2d"
	function isoAge(isoString) {
	  if (!isoString) return '-';
	  const then = new Date(isoString);
	  const now = new Date();
	  const diff = now - then;
	  const sec = Math.floor(diff / 1000);
	  const min = Math.floor(sec / 60);
	  const hr  = Math.floor(min / 60);
	  const day = Math.floor(hr / 24);

	  if (day > 0) return day + 'd';
	  if (hr  > 0) return hr  + 'h';
	  if (min > 0) return min + 'm';
	  return sec + 's';
	}

	
	/**
	 * Poll until a given service (or derived service name) has at least one matching pod.
	 * - serviceName: the service name (or service-like name derived from pod/deployment)
	 * - namespace: namespace to check
	 * - opts: { intervalMs: 3000, timeoutMs: 60000 } optional
	 *
	 * Resolves true if pods found, false if timeout reached.
	 */
	async function pollUntilServiceHasPods(serviceName, namespace, opts = {}) {
	  const intervalMs = opts.intervalMs || 3000;
	  const timeoutMs = opts.timeoutMs || 60000;
	  const started = Date.now();

	  // Helper: checks if service selector matches any pod labels
	  const checkOnce = async () => {
	    try {
	      // try list endpoints (tolerant)
	      const svcCandidates = [
	        `/api/v1/namespaces/${encodeURIComponent(namespace)}/services/${encodeURIComponent(serviceName)}`,
	        `/api/services/${encodeURIComponent(namespace)}/${encodeURIComponent(serviceName)}`,
	        `/api/services?namespace=${encodeURIComponent(namespace)}` // fallback to list if no single-get
	      ];
	      const podsCandidates = [
	        `/api/pods?namespace=${encodeURIComponent(namespace)}`,
	        `/api/v1/namespaces/${encodeURIComponent(namespace)}/pods`
	      ];

	      // Try to fetch the service object first
	      let svcRes = await fetchWithFallback([
	        `/api/v1/namespaces/${encodeURIComponent(namespace)}/services/${encodeURIComponent(serviceName)}`,
	        `/api/services/${encodeURIComponent(namespace)}/${encodeURIComponent(serviceName)}`,
	        `/api/services?namespace=${encodeURIComponent(namespace)}`
	      ]);

	      let serviceObj = null;
	      if (svcRes.res && svcRes.res.ok) {
	        try {
	          const payload = await svcRes.res.json();
	          // if we got items (list), try to find by name
	          if (Array.isArray(payload)) {
	            serviceObj = payload.find(s => (s.metadata && s.metadata.name) === serviceName) || null;
	          } else if (payload && Array.isArray(payload.items)) {
	            serviceObj = payload.items.find(s => s.metadata?.name === serviceName) || null;
	          } else if (payload && payload.metadata && payload.metadata.name === serviceName) {
	            serviceObj = payload;
	          }
	        } catch (err) {
	          // ignore parse failures
	        }
	      }

	      // If we couldn't fetch service object, build a selector by convention: empty selector -> no pods; else try label derived matching
	      const selector = (serviceObj && serviceObj.spec && serviceObj.spec.selector) ? serviceObj.spec.selector : null;

	      // fetch pods
	      const podsRes = await fetchWithFallback(podsCandidates);
	      let podsList = [];
	      if (podsRes.res && podsRes.res.ok) {
	        const p = await podsRes.res.json().catch(()=>null);
	        if (Array.isArray(p)) podsList = p;
	        else if (p && Array.isArray(p.items)) podsList = p.items;
	      }

	      if (!selector || Object.keys(selector).length === 0) {
	        // If selector is absent, try to match using a best-effort heuristic:
	        // treat serviceName as deployment prefix and look for pods whose name starts with that prefix
	        return podsList.some(p => (p.metadata && p.metadata.name && p.metadata.name.startsWith(serviceName + '-')));
	      }

	      // check if any pod's labels match selector
	      return podsList.some(p => {
	        const labels = (p.metadata && p.metadata.labels) || {};
	        return Object.entries(selector).every(([k, v]) => labels[k] === v);
	      });

	    } catch (err) {
	      console.warn('pollUntilServiceHasPods: checkOnce error', err);
	      return false;
	    }
	  };

	  // fast first check
	  if (await checkOnce()) return true;

	  // poll loop
	  while (Date.now() - started < timeoutMs) {
	    await new Promise(res => setTimeout(res, intervalMs));
	    if (await checkOnce()) return true;
	  }

	  return false; // timed out
	}

	
	// Build a table row for a Service (used when ServicesZero filter selected)
	// Build a table row for a Service (accepts either a Service object or a plain string name)
	function createServiceRow(svc) {
	  let name = '—', ns = currentNamespace || 'default', labels = {}, typeInfo = '';
	  if (!svc) { name = '—'; }
	  else if (typeof svc === 'string') { name = svc; }
	  else if (typeof svc === 'object') {
	    name = svc.metadata?.name || svc.name || '—';
	    ns = svc.metadata?.namespace || ns;
	    labels = svc.metadata?.labels || svc.spec?.selector || {};
	    typeInfo = svc.spec?.type || '';
	  } else {
	    name = String(svc);
	  }

	  const tr = document.createElement('tr');

	  const nameTd = document.createElement('td');
	  nameTd.innerHTML = `<strong>${name}</strong>
	                      <div class="text-muted small">${typeInfo} ${labels && Object.keys(labels).length ? Object.entries(labels).map(([k,v])=>k+':'+v).join(', ') : ''}</div>`;

	  const statusTd = document.createElement('td');
	  const badge = document.createElement('span');
	  badge.className = 'badge bg-warning';
	  badge.textContent = '0 pods';
	  statusTd.appendChild(badge);

	  const ageTd = document.createElement('td');
	  // If service object provided, show age; otherwise '-'
	  ageTd.textContent = svc && svc.metadata && svc.metadata.creationTimestamp ? isoAge(svc.metadata.creationTimestamp) : '-';

	  const actionsTd = document.createElement('td');

	  const makeBtn = (text, cls = 'btn', onClick) => {
	    const b = document.createElement('button');
	    b.className = cls;
	    b.textContent = text;
	    b.onclick = onClick;
	    return b;
	  };

	  // Describe (try service describe endpoint; fallback to alert)
	  actionsTd.appendChild(makeBtn('Describe', 'btn outline small', async () => {
	    try {
	      const r = await fetch(`/api/deployments/${encodeURIComponent(ns)}/${encodeURIComponent(name)}`); // maybe service name maps to deployment
	      if (r.ok) { alert(JSON.stringify(await r.json(), null, 2)); return; }
	    } catch (e) { /* ignore */ }
	    alert('Describe: ' + name);
	  }));

	  // Edit ConfigMap (derive)
	  actionsTd.appendChild(makeBtn('Edit ConfigMap', 'btn outline small', async () => {
	    const cmName = baseServiceNameFromPod(name);
	    await openFullConfigMap(ns, cmName);
	  }));

	  // Edit Deployment (NEW)
	  actionsTd.appendChild(makeBtn('Edit Deployment', 'btn outline small', async () => {
	    const depName = baseServiceNameFromPod(name);
	    await openFullDeployment(ns, depName);
	  }));

	  // Set Replicas
	  actionsTd.appendChild(makeBtn('Set Replicas', 'btn outline small', async () => {
	    await openReplicasModal(ns, name);
	  }));

	  tr.appendChild(nameTd);
	  tr.appendChild(statusTd);
	  tr.appendChild(ageTd);
	  tr.appendChild(actionsTd);
	  return tr;
	}




	/* ---------------- Fetch pods + summary and render ---------------- */
	async function fetchSummaryAndRender() {
	  try {
	    const ns = currentNamespace;
	    const [podsRes, summaryRes] = await Promise.all([
	      fetch('/api/pods?namespace=' + encodeURIComponent(ns)),
	      fetch('/api/summary?namespace=' + encodeURIComponent(ns))
	    ]);
	    if (!podsRes.ok || !summaryRes.ok) {
	      console.error('fetch error', podsRes.status, summaryRes.status);
	      return;
	    }
	    const pods = await podsRes.json();
	    const summary = await summaryRes.json();

	    // Update counts
	    document.getElementById('count-running').textContent = summary.running ?? 0;
	    document.getElementById('count-pending').textContent = summary.pending ?? 0;
	    document.getElementById('count-abnormal').textContent = summary.abnormal ?? 0;
	    document.getElementById('count-services-zero').textContent = summary.servicesWithZeroPods ?? 0;

	    // Render filtered pods
	    const search = (searchInput?.value || '').toLowerCase();
	    podsBody.innerHTML = '';

	    const filtered = pods.filter(p => {
	      // status filter
	      if (statusFilter) {
	        if (statusFilter === 'Running' && p.status !== 'Running') return false;
	        if (statusFilter === 'Pending' && p.status !== 'Pending') return false;
	        if (statusFilter === 'Abnormal') {
	          if (!(p.status === 'Failed' || (p.status && normalizePodStatus(p).includes('crash')) || (p.restartCount && p.restartCount > 0))) return false;
	        }
	        if (statusFilter === 'ServicesZero') return false; // special handled below
	      }
	      // search by name
	      if (search && !(p.name || '').toLowerCase().includes(search)) return false;
	      return true;
	    });

	    filtered.forEach(p => podsBody.appendChild(createPodRow(p)));

	    // ServicesZero card: show message
		// ServicesZero card: show message or list services with zero pods
		if (statusFilter === 'ServicesZero') {
		  // Try to fetch services and pods, compute which services have zero matching pods
		  podsBody.innerHTML = '<tr><td colspan="4">Loading services with zero pods…</td></tr>';
		  try {
		    const ns = currentNamespace;
		    // Try the canonical and proxy endpoints for services (fallback tolerant)
		    const svcCandidates = [
		      `/api/services?namespace=${encodeURIComponent(ns)}`,
		      `/api/v1/namespaces/${encodeURIComponent(ns)}/services`,
		      `/apis/v1/namespaces/${encodeURIComponent(ns)}/services`,
		      `/services?namespace=${encodeURIComponent(ns)}`
		    ];
		    const podsCandidates = [
		      `/api/pods?namespace=${encodeURIComponent(ns)}`,
		      `/api/v1/namespaces/${encodeURIComponent(ns)}/pods`,
		      `/apis/v1/namespaces/${encodeURIComponent(ns)}/pods`
		    ];

		    const svcRes = await fetchWithFallback(svcCandidates);
		    const podsRes = await fetchWithFallback(podsCandidates);

		    if (!svcRes.res || !svcRes.res.ok) {
		      console.warn('ServicesZero: services listing not available, tried:', svcCandidates);
		      podsBody.innerHTML = '<tr><td colspan="4">Services list not available from backend (tried multiple endpoints).</td></tr>';
		      return;
		    }
		    if (!podsRes.res || !podsRes.res.ok) {
		      console.warn('ServicesZero: pods listing not available, tried:', podsCandidates);
		      podsBody.innerHTML = '<tr><td colspan="4">Pods list not available from backend (tried multiple endpoints).</td></tr>';
		      return;
		    }

		    const servicesPayload = await svcRes.res.json().catch(()=>null);
		    const podsPayload = await podsRes.res.json().catch(()=>null);

		    // Normalize shapes: kube returns { items: [...] } often
		    const servicesList = Array.isArray(servicesPayload) ? servicesPayload
		                          : (servicesPayload && Array.isArray(servicesPayload.items) ? servicesPayload.items : []);
		    const podsList = Array.isArray(podsPayload) ? podsPayload
		                      : (podsPayload && Array.isArray(podsPayload.items) ? podsPayload.items : []);

		    // If no services, show a friendly message
		    if (!servicesList || servicesList.length === 0) {
		      podsBody.innerHTML = '<tr><td colspan="4">No services found in this namespace.</td></tr>';
		      return;
		    }

		    // Build an index of pods by labels for quick matching
		    const podLabelSet = podsList.map(p => ({ name: p.metadata?.name, labels: p.metadata?.labels || {} }));

		    // Helper to test if a service selector matches any pod labels
		    function serviceHasMatchingPod(selector) {
		      if (!selector || Object.keys(selector).length === 0) return false;
		      return podLabelSet.some(p => {
		        const labels = p.labels || {};
		        return Object.entries(selector).every(([k,v]) => labels[k] === v);
		      });
		    }

		    // Compute services that have zero pods
		    const zeroServices = servicesList.filter(s => {
		      const selector = s.spec?.selector || {};
		      return !serviceHasMatchingPod(selector);
		    });

		    if (!zeroServices || zeroServices.length === 0) {
		      podsBody.innerHTML = '<tr><td colspan="4">No services with zero pods were found.</td></tr>';
		      return;
		    }

		    // Render the zeroServices list with the same table structure
		    podsBody.innerHTML = '';
		    zeroServices.forEach(svc => podsBody.appendChild(createServiceRow(svc)));
		  } catch (err) {
		    console.error('ServicesZero render failed', err);
		    podsBody.innerHTML = '<tr><td colspan="4">Error computing services with zero pods.</td></tr>';
		  }

		  return; // done handling ServicesZero
		}

	  } catch (err) {
	    console.error('refresh error', err);
	  }
	}

	/* ---------------- Restart pod ---------------- */
	async function restartPod(namespace, podName) {
	  if (!confirm(`Delete pod ${podName} to force restart?`)) return;

	  try {
	    const url = `/api/pods/${encodeURIComponent(namespace)}/${encodeURIComponent(podName)}/restart`;
	    const res = await fetch(url, { method: 'POST' });

	    if (!res.ok) {
	      const txt = await res.text().catch(() => res.statusText);
	      alert(`Restart failed (${res.status}): ${txt}`);
	      return;
	    }

	    alert('Restart requested.');
	    // Optionally poll or just refresh summary/list:
	    if (typeof fetchSummaryAndRender === 'function') fetchSummaryAndRender();
	  } catch (e) {
	    alert('Error: ' + e.message);
	  }
	}



	/* ---------------- Namespaces loader ---------------- */
	async function loadNamespaces() {
	  const sel = namespaceSelect;
	  if (!sel) return;
	  sel.innerHTML = '';
	  const loadOpt = document.createElement('option'); loadOpt.value = 'loading'; loadOpt.textContent = 'Loading...'; loadOpt.disabled = true; sel.appendChild(loadOpt);
	  try {
	    const r = await fetch('/api/namespaces');
	    if (!r.ok) throw new Error('HTTP ' + r.status);
	    const list = await r.json();
	    sel.innerHTML = '';
	    const allOpt = document.createElement('option'); allOpt.value = 'all'; allOpt.textContent = 'All namespaces'; sel.appendChild(allOpt);
	    if (!Array.isArray(list) || list.length === 0) {
	      const none = document.createElement('option'); none.value='none'; none.textContent='-- no namespaces --'; none.disabled=true; sel.appendChild(none);
	      currentNamespace = 'all';
	      return;
	    }
	    list.forEach(ns => { const o = document.createElement('option'); o.value = ns; o.textContent = ns; sel.appendChild(o); });
	    if ([...sel.options].some(o => o.value === currentNamespace)) sel.value = currentNamespace; else { sel.value = 'all'; currentNamespace = 'all'; }
	  } catch (err) {
	    console.error('namespaces load failed', err);
	    sel.innerHTML = ''; const e = document.createElement('option'); e.value='error'; e.textContent='-- failed to load --'; e.disabled=true; sel.appendChild(e);
	  }
	}

	/* ---------------- Shared modal open/close ---------------- */
	function openModal(title, mode, namespace=null, target=null, resourceVersion=null) {
	  modalMode = mode;
	  modalContext = { namespace, targetName: target, resourceVersion };
	  modalTitle.textContent = title;
	  modalBody.innerHTML = ''; // content filled by mode-specific loaders
	  modalOverlay.classList.remove('hidden');
	  // set the save handler appropriately
	  modalSaveBtn.onclick = () => {
	    if (modalMode === 'configmap-full') saveFullConfigMap();
	    else if (modalMode === 'deployment-full') saveFullDeployment();
	    else if (modalMode === 'replicas') saveReplicas();
	    else if (modalMode === 'cm-keys-edit') saveConfigMapKeyEdits();
	  };

	}
	function closeModal() {
	  modalOverlay.classList.add('hidden');
	  modalMode = null;
	  modalContext = { namespace: null, targetName: null, resourceVersion: null };
	  modalBody.innerHTML = '';
	}

	/* ---------------- Full notepad-style ConfigMap editor (uses fetchWithFallback) ---------------- */
	const cmRaw = {
	  name: null,
	  ns: 'default',
	  rv: '',
	  originalData: {},    // { key: string }
	  textarea: null
	};

	function esc(s){ return String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

	function computeChangedKeys(oldMap, newMap) {
	  const out = [];
	  const all = new Set([...Object.keys(oldMap), ...Object.keys(newMap)]);
	  for (const k of all) {
	    const a = oldMap[k] ?? '';
	    const b = newMap[k] ?? '';
	    if (a !== b) out.push({ key:k, oldVal:a, newVal:b });
	  }
	  return out.sort((x,y) => x.key.localeCompare(y.key));
	}

	function showDiffModal(changes) {
	  return new Promise(resolve => {
	    const overlay = document.createElement('div');
	    overlay.className = 'modal-overlay'; overlay.style.display = 'flex';
	    overlay.innerHTML = `
	      <div class="modal xlarge">
	        <div class="modal-header">
	          <h3>Review changes (${changes.length})</h3>
	          <button class="modal-close" id="diffCloseBtn">×</button>
	        </div>
	        <div class="modal-body" style="max-height:65vh;overflow:auto;">
	          ${changes.map(ch => `
	            <div class="diff-block">
	              <div class="diff-key"><strong>${esc(ch.key)}</strong></div>
	              <div class="diff-grid">
	                <div class="diff-col"><div class="diff-title">Old</div><pre class="diff-pre">${esc(ch.oldVal)}</pre></div>
	                <div class="diff-col"><div class="diff-title">New</div><pre class="diff-pre">${esc(ch.newVal)}</pre></div>
	              </div>
	            </div>`).join('')}
	        </div>
	        <div class="modal-footer">
	          <button class="btn outline" id="diffCancelBtn">Cancel</button>
	          <button class="btn" id="diffConfirmBtn">Confirm & Save</button>
	        </div>
	      </div>`;
	    document.body.appendChild(overlay);
	    const done = ok => { overlay.remove(); resolve(ok); };
	    overlay.querySelector('#diffCloseBtn').onclick = () => done(false);
	    overlay.querySelector('#diffCancelBtn').onclick = () => done(false);
	    overlay.querySelector('#diffConfirmBtn').onclick = () => done(true);
	  });
	}

	// Open editor (loads full CM, shows only data as JSON)
	async function openFullConfigMap(namespace, name) {
	  openModal(`Edit ConfigMap — ${name}`, 'configmap-full', namespace, name, null);
	  modalBody.innerHTML = '<p style="color:var(--muted)">Loading ConfigMap...</p>';

	  const url = `/api/configmap/${encodeURIComponent(name)}/full?namespace=${encodeURIComponent(namespace)}`;
	  const res = await fetch(url);
	  if (!res.ok) {
	    const txt = await res.text().catch(()=>res.statusText);
	    modalBody.innerHTML = `<p style="color:var(--danger)">Load error (${res.status}): ${txt}</p>`;
	    return;
	  }
	  const payload = await res.json().catch(()=>null);
	  if (!payload) { modalBody.innerHTML = `<p style="color:var(--danger)">Malformed ConfigMap</p>`; return; }

	  cmRaw.name = name;
	  cmRaw.ns = namespace;
	  cmRaw.rv = payload.metadata?.resourceVersion || '';
	  cmRaw.originalData = payload.data || {};

	  // Sort keys for stable display
	  const sorted = Object.keys(cmRaw.originalData).sort()
	    .reduce((m,k)=> (m[k]=cmRaw.originalData[k], m), {});

	  modalBody.innerHTML = `
	    <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px;color:var(--muted);font-size:13px;">
	      <div><strong>${esc(name)}</strong> — ${esc(namespace)}</div>
	      <div style="margin-left:auto;">
	        <button id="cmDownloadBtn" class="btn outline small">Download</button>
	      </div>
	    </div>
	    <textarea id="cmRawTextarea" spellcheck="false"
	      style="width:100%;height:480px;padding:12px;font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,'Courier New',monospace;
	             font-size:13px;background:#0d1117;color:#e6eef6;border-radius:8px;border:1px solid rgba(255,255,255,0.06);resize:vertical;"></textarea>
	    <div style="margin-top:6px;color:var(--muted);font-size:12px;">
	      Tip: values must be strings. We’ll coerce numbers/booleans to strings on save.
	    </div>
	  `;
	  cmRaw.textarea = document.getElementById('cmRawTextarea');
	  cmRaw.textarea.value = JSON.stringify(sorted, null, 2);

	  // Download current data
	  document.getElementById('cmDownloadBtn').onclick = () => {
	    const blob = new Blob([JSON.stringify(sorted, null, 2)], { type: 'application/json' });
	    const href = URL.createObjectURL(blob);
	    const a = Object.assign(document.createElement('a'), { href, download: `${name}-configmap-data.json` });
	    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(href);
	  };

	  // Wire save
	  if (window.modalSaveBtn) {
	    modalSaveBtn.style.display = '';
	    modalSaveBtn.onclick = () => saveFullConfigMapRaw();
	  }
	}

	// Save (parse raw JSON, diff, PUT only data map)
	async function saveFullConfigMapRaw() {
	  const btn = window.modalSaveBtn || document.getElementById('saveFullCmBtn');
	  if (!cmRaw.textarea) { alert('Editor not found'); return; }

	  btn && (btn.disabled = true, btn.textContent = 'Validating...');

	  let parsed;
	  try {
	    parsed = JSON.parse(cmRaw.textarea.value);
	  } catch (e) {
	    alert('JSON parse error: ' + e.message);
	    btn && (btn.disabled = false, btn.textContent = 'Save');
	    return;
	  }

	  // Coerce values to strings (ConfigMap data values must be strings)
	  const newData = {};
	  for (const [k,v] of Object.entries(parsed)) {
	    newData[k] = (v == null) ? '' : String(v);
	  }

	  const changes = computeChangedKeys(cmRaw.originalData, newData);
	  if (changes.length === 0) {
	    alert('No changes to save.');
	    btn && (btn.disabled = false, btn.textContent = 'Save');
	    return;
	  }

	  const ok = await showDiffModal(changes);
	  if (!ok) { btn && (btn.disabled = false, btn.textContent = 'Save'); return; }

	  btn && (btn.textContent = 'Saving...');

	  try {
	    const url = `/api/configmap/${encodeURIComponent(cmRaw.name)}/full?namespace=${encodeURIComponent(cmRaw.ns)}${cmRaw.rv ? `&resourceVersion=${encodeURIComponent(cmRaw.rv)}` : ''}`;
	    const res = await fetch(url, {
	      method: 'PUT',
	      headers: { 'Content-Type': 'application/json' },
	      body: JSON.stringify(newData)
	    });
	    if (!res.ok) {
	      const txt = await res.text().catch(()=>res.statusText);
	      alert(`Save failed (${res.status}): ${txt}`);
	      return;
	    }
	    alert('ConfigMap saved.');
	    cmRaw.originalData = newData;   // refresh baseline
	    if (typeof closeModal === 'function') closeModal();
	    if (typeof fetchSummaryAndRender === 'function') fetchSummaryAndRender();
	  } catch (e) {
	    alert('Error: ' + e.message);
	  } finally {
	    btn && (btn.disabled = false, btn.textContent = 'Save');
	  }
	}

	// Open Logs /////// 
	
	function qp(obj) {
	  const u = new URLSearchParams();
	  Object.entries(obj).forEach(([k,v]) => {
	    if (v !== undefined && v !== null && v !== '' && v !== false) u.set(k, String(v));
	  });
	  const s = u.toString();
	  return s ? '?' + s : '';
	}

	async function openLogs(namespace, podName) {
	  const DEFAULT_LINES = 5000;
	  openModal(`Logs — ${podName}`, 'logs', namespace, podName, null);
	  modalBody.innerHTML = '<div style="color:var(--muted)">Loading containers…</div>';
	  if (window.modalSaveBtn) modalSaveBtn.style.display = 'none';

	  // 1) Fetch pod to discover containers
	  let pod;
	  try {
	    const res = await fetch(`/api/pods?namespace=${encodeURIComponent(namespace)}`);
	    const list = await res.json();
	    pod = Array.isArray(list) ? list.find(p => p?.metadata?.name === podName) : null;
	  } catch {}
	  const containers = (pod?.status?.containerStatuses || []).map(cs => cs?.name).filter(Boolean);
	  const initContainer = containers[0] || '';

	  // 2) Render controls
	  modalBody.innerHTML = `
	    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px;">
	      <label style="font-size:12px;color:var(--muted)">Container:</label>
	      <select id="logContainer" class="inp" style="min-width:180px;">
	        ${containers.length ? containers.map(n => `<option value="${n}">${n}</option>`).join('') : '<option value="">(single-container or unknown)</option>'}
	      </select>

	      <label style="font-size:12px;color:var(--muted);margin-left:12px;">Previous</label>
	      <input id="logPrevious" type="checkbox" />

	      <label style="font-size:12px;color:var(--muted);margin-left:12px;">sinceSeconds</label>
	      <input id="logSince" class="inp" type="number" min="0" placeholder="e.g. 600" style="width:110px;" />

	      <label style="font-size:12px;color:var(--muted);margin-left:12px;">lines</label>
	      <input id="logLines" class="inp" type="number" min="1" value="${DEFAULT_LINES}" style="width:110px;" />

	      <button id="logRefresh" class="btn" style="margin-left:auto;">Refresh</button>
	      <button id="logDownload" class="btn outline">Download</button>
	    </div>
	    <pre id="logsPre" style="max-height:65vh;overflow:auto;white-space:pre-wrap;background:#0d1117;color:#e6eef6;border:1px solid rgba(255,255,255,0.06);border-radius:8px;padding:10px;"></pre>
	  `;

	  const $container = document.getElementById('logContainer');
	  const $previous  = document.getElementById('logPrevious');
	  const $since     = document.getElementById('logSince');
	  const $lines     = document.getElementById('logLines');
	  const $refresh   = document.getElementById('logRefresh');
	  const $download  = document.getElementById('logDownload');
	  const $pre       = document.getElementById('logsPre');

	  if (initContainer) $container.value = initContainer;

	  async function loadLogs() {
	    $pre.textContent = 'Loading…';
	    try {
	      const params = {
	        lines: $lines.value ? parseInt($lines.value, 10) : undefined,
	        sinceSeconds: $since.value ? parseInt($since.value, 10) : undefined,
	        container: $container.value || undefined,
	        previous: $previous.checked || undefined
	      };
	      const url = `/api/pods/${encodeURIComponent(namespace)}/${encodeURIComponent(podName)}/logs` + qp(params);
	      const res = await fetch(url, { headers: { 'Accept': 'text/plain' } });
	      const txt = await res.text();
	      if (!res.ok) {
	        $pre.textContent = `Load error (${res.status}): ${txt}`;
	        return;
	      }
	      // strip ANSI colors for readability
	      const clean = txt.replace(/\x1b\[[0-9;]*m/g, '');
	      $pre.textContent = clean;
	    } catch (e) {
	      $pre.textContent = 'Error: ' + e.message;
	    }
	  }

	  $refresh.onclick = loadLogs;
	  $download.onclick = () => {
	    const blob = new Blob([$pre.textContent || ''], { type: 'text/plain' });
	    const url = URL.createObjectURL(blob);
	    const a = document.createElement('a');
	    a.href = url; a.download = `${podName}${$container.value ? '-' + $container.value : ''}.log`;
	    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
	  };

	  // initial load
	  loadLogs();
	}

	
	async function saveFullConfigMapSmart() {
	  const btn = window.modalSaveBtn || document.getElementById('saveFullCmBtn');
	  btn && (btn.disabled = true, btn.textContent = 'Preparing diff...');

	  try {
	    const newData = (cmCtx.mode === 'raw-json') ? raw_collectData() : perKey_collectData();
	    const changes = computeChangedKeys(cmCtx.originalData, newData);

	    if (changes.length === 0) { alert('No changes to save.'); return; }

	    const ok = await showDiffModal(changes);
	    if (!ok) return;

	    btn && (btn.textContent = 'Saving...');

	    const url = `/api/configmap/${encodeURIComponent(cmCtx.name)}/full?namespace=${encodeURIComponent(cmCtx.ns)}${cmCtx.rv ? `&resourceVersion=${encodeURIComponent(cmCtx.rv)}` : ''}`;

	    const res = await fetch(url, {
	      method: 'PUT',
	      headers: { 'Content-Type': 'application/json' },
	      body: JSON.stringify(newData)   // only the data map
	    });

	    if (!res.ok) {
	      const txt = await res.text().catch(()=>res.statusText);
	      alert(`Save failed (${res.status}): ${txt}`);
	      return;
	    }

	    alert('ConfigMap saved.');
	    cmCtx.originalData = newData;     // refresh baseline
	    if (typeof closeModal === 'function') closeModal();
	    if (typeof fetchSummaryAndRender === 'function') fetchSummaryAndRender();
	  } catch (e) {
	    alert('Error: ' + e.message);
	  } finally {
	    if (btn) { btn.disabled = false; btn.textContent = 'Save'; }
	  }
	}



	/* ---------------- Replicas modal (tries multiple endpoints) ---------------- */
	function openReplicasModal(namespace, deploymentName) {
	  openModal(`Set Replicas — ${deploymentName}`, 'replicas', namespace, deploymentName, null);

	  modalBody.innerHTML = `
	    <div id="replicasPanel">
	      <div style="margin-bottom:10px;">
	        <label class="lbl">Deployment</label>
	        <input id="deploySelect" class="inp" value="${deploymentName}" readonly />
	      </div>
	      <div>
	        <label class="lbl">Replicas</label>
	        <input id="replicaInput" class="inp" type="number" min="0" step="1" placeholder="e.g. 2" />
	      </div>
	    </div>
	  `;

	  // Prevent accidental form submits (if any ancestor is a form)
	  modalSaveBtn.setAttribute('type', 'button');

	  // Hitting Enter in the replicas input should NOT submit a form
	  const ri = document.getElementById('replicaInput');
	  ri.addEventListener('keydown', (e) => {
	    if (e.key === 'Enter') {
	      e.preventDefault();
	      saveReplicas();
	    }
	  });
	}


	/* ---------------- Deployment editor: open + save ---------------- */
	async function openFullDeployment(namespace, name) {
	  openModal(`Edit Deployment — ${name}`, 'deployment-full', namespace, name, null);
	  modalBody.innerHTML = '<p style="color:var(--muted)">Loading deployment...</p>';

	  // sensible candidate list; avoid list-style /api/deployments/... shapes that produce 404 static resource errors
	  const candidates = [
	      `/api/deployments/${encodeURIComponent(namespace)}/${encodeURIComponent(name)}`
	    ];

	  const result = await fetchWithFallback(candidates);
	  if (!result.res) {
	    modalBody.innerHTML = `<p style="color:var(--danger)">Deployment '${name}' not found (tried multiple endpoints).</p>`;
	    console.info('openFullDeployment: none matched', candidates);
	    return;
	  }
	  console.info('openFullDeployment: used endpoint', result.url);

	  if (!result.res.ok) {
	    const txt = await result.res.text().catch(()=>result.res.statusText);
	    modalBody.innerHTML = `<p style="color:var(--danger)">Load error (${result.res.status}): ${txt}</p>`;
	    return;
	  }

	  let payload;
	  try {
	    payload = await result.res.json();
	  } catch (err) {
	    modalBody.innerHTML = `<p style="color:var(--danger)">Malformed JSON from ${result.url}</p>`;
	    return;
	  }

	  modalContext.resourceVersion = payload.metadata?.resourceVersion || null;
	  const text = JSON.stringify(payload || {}, null, 2);
	  modalBody.innerHTML = `
	    <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;">
	      <div style="color:var(--muted);font-size:13px;">Replica target: ${payload.spec?.replicas ?? '-'}</div>
	      <div style="margin-left:auto"><button class="btn outline" id="downloadDeployBtn">Download</button></div>
	    </div>
	    <textarea id="fullDeploymentTextarea" spellcheck="false" style="width:100%;height:420px;padding:12px;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Courier New', monospace; font-size:13px; background:var(--panel); color:#e6eef6; border-radius:8px; border:1px solid rgba(255,255,255,0.04);"></textarea>
	  `;
	  document.getElementById('fullDeploymentTextarea').value = text;
	  document.getElementById('downloadDeployBtn').onclick = () => {
	    const blob = new Blob([document.getElementById('fullDeploymentTextarea').value], { type: 'application/json' });
	    const url = URL.createObjectURL(blob);
	    const a = document.createElement('a'); a.href = url; a.download = `${name}-deployment.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
	  };
	}


	async function saveFullDeployment() {
	  const ta = document.getElementById('fullDeploymentTextarea');
	  if (!ta) return alert('Deployment editor not found');
	  let parsed;
	  try {
	    parsed = JSON.parse(ta.value);
	  } catch (err) {
	    alert('JSON parse error: ' + err.message);
	    return;
	  }

	  parsed.metadata = parsed.metadata || {};
	  parsed.metadata.name = parsed.metadata.name || modalContext.targetName;
	  parsed.metadata.namespace = parsed.metadata.namespace || modalContext.namespace;

	  const body = JSON.stringify(parsed, null, 2);
	  const url = `/api/deployments/${encodeURIComponent(modalContext.namespace)}/${encodeURIComponent(modalContext.targetName)}`;

	  modalSaveBtn.disabled = true;
	  modalSaveBtn.textContent = 'Saving...';

	  try {
	    const res = await fetch(url, {
	      method: 'PUT',
	      headers: { 'Content-Type': 'application/json' },
	      body
	    });

	    if (!res.ok) {
	      const msg = await res.text().catch(() => res.statusText);
	      alert(`Save failed (${res.status}): ${msg}`);
	    } else {
	      alert('Deployment updated successfully.');
	      closeModal();
	      fetchSummaryAndRender();
	    }
	  } catch (err) {
	    alert('Error saving deployment: ' + err.message);
	  } finally {
	    modalSaveBtn.disabled = false;
	    modalSaveBtn.textContent = 'Save';
	  }
	}




	async function saveReplicas() {
	  const deploy = document.getElementById('deploySelect')?.value;
	  const replicas = parseInt(document.getElementById('replicaInput')?.value, 10);

	  if (!deploy) { alert('No deployment selected.'); return; }
	  if (Number.isNaN(replicas)) { alert('Specify a valid number.'); return; }

	  modalSaveBtn.disabled = true;
	  modalSaveBtn.textContent = 'Scaling...';

	  try {
	    const encNS = encodeURIComponent(currentNamespace);
	    const encDeploy = encodeURIComponent(deploy);
	    const url = `/api/deployments/${encNS}/${encDeploy}/scale`;

	    const res = await fetch(url, {
	      method: 'POST',
	      headers: { 'Content-Type': 'application/json' },
	      body: JSON.stringify({ replicas })
	    });

	    if (!res.ok) {
	      const body = await res.text().catch(() => res.statusText);
	      alert('Scale failed: ' + res.status + ' ' + body);
	    } else {
	      alert('Scale request accepted.');
	      closeModal();
	      fetchSummaryAndRender?.();
	    }
	  } catch (err) {
	    alert('Error scaling: ' + err.message);
	  } finally {
	    modalSaveBtn.disabled = false;
	    modalSaveBtn.textContent = 'Save';
	  }
	}




	/* ---------------- Modal close wiring ---------------- */
	document.addEventListener('click', function (e) {
	  if (e.target && e.target.matches && e.target.matches('.modal-close')) {
	    closeModal();
	  }
	});
	document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !modalOverlay.classList.contains('hidden')) closeModal(); });

	/* ---------------- Event bindings & init ---------------- */
	refreshBtn.addEventListener('click', async () => {
	  const ns = (namespaceSelect?.value) || 'default';
	  // Optional: show immediate UI feedback
	  const originalText = refreshBtn.textContent;
	  try {
	    refreshBtn.disabled = true;
	    refreshBtn.textContent = 'Auth...';
	    // Call backend to run the login script with the namespace
	    const res = await fetch(`/api/run-login-script?namespace=${encodeURIComponent(ns)}`, { method: 'POST' });
	    const payload = await res.json().catch(()=>null);

	    if (!res.ok) {
	      console.error('login script failed', payload);
	      alert('Cluster login failed: ' + (payload?.error || payload?.stderr || 'unknown error'));
	      return; // stop further refresh
	    }

	    // Optionally show stdout in console
	    console.info('login script output', payload?.stdout);

	    // Now kubeconfig should be updated — continue with normal refresh
	    refreshBtn.textContent = 'Refreshing...';
	    await fetchSummaryAndRender();
	  } catch (err) {
	    console.error('error running login script', err);
	    alert('Failed to run login script: ' + err.message);
	  } finally {
	    refreshBtn.disabled = false;
	    refreshBtn.textContent = originalText;
	  }
	});

	if (searchInput) searchInput.addEventListener('input', () => { clearTimeout(window.__pod_search_timer); window.__pod_search_timer = setTimeout(fetchSummaryAndRender, 180); });
	if (namespaceSelect) namespaceSelect.addEventListener('change', () => { currentNamespace = namespaceSelect.value; fetchSummaryAndRender(); });

	(async function init() {
	  await loadNamespaces();
	  updateCardActiveState();
	  await fetchSummaryAndRender();
	  setInterval(fetchSummaryAndRender, 5000);
	})();
	
	function baseServiceNameFromPod(podName) {
	  if (!podName) return podName;
	  const parts = podName.split("-");
	  if (parts.length > 2) {
	    return parts.slice(0, -2).join("-");
	  }
	  return podName;
	}

	</script>


  </div>
</div>

</html>
